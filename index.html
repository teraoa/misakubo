<!-- <!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Edge Lights</title>
</head>
<body>
    <script type="module" src="script.js"></script>
</body>
</html>

////// ä»¥ä¸‹ã€å†™çœŸã‚’æ°´é¢ã®æºã‚‰ãã«å¤‰æ›

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2D Water Effect</title>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@latest/build/three.module.min.js"
            }
        }
    </script>
</head>
<body>
    <script type="module">
        import * as THREE from 'three';
        import { Water } from 'https://cdn.jsdelivr.net/npm/three@latest/examples/jsm/objects/Water2.js';

        // ã‚·ãƒ¼ãƒ³ã€ã‚«ãƒ¡ãƒ©ã€ãƒ¬ãƒ³ãƒ€ãƒ©ãƒ¼ã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
        const scene = new THREE.Scene();
        const camera = new THREE.OrthographicCamera(-5, 5, 5, -5, 1, 10);
        camera.position.z = 5;

        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // ç¾åœ°å†™çœŸã®ãƒ­ãƒ¼ãƒ‰
        const textureLoader = new THREE.TextureLoader();
        const imageURL = './OPENC-02.png'; // â† ç¾åœ°å†™çœŸã®ãƒ‘ã‚¹ã‚’è¨­å®š
        const imageTexture = textureLoader.load(imageURL);

        // æ°´é¢ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼
        const waterShader = new THREE.ShaderMaterial({
            uniforms: {
                time: { value: 0 },
                texture1: { value: imageTexture },
                resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform float time;
                uniform sampler2D texture1;
                varying vec2 vUv;

                void main() {
                    float wave = sin(vUv.y * 10.0 + time) * 0.005;
                    vec2 distortedUV = vUv + vec2(wave, wave);
                    vec4 color = texture2D(texture1, distortedUV);
                    color.rgb *= vec3(0.8, 0.9, 1.0);
                    gl_FragColor = color;
                }
            `
        });

        // æ°´é¢ã®æç”»
        const waterPlane = new THREE.Mesh(new THREE.PlaneGeometry(10, 10), waterShader);
        scene.add(waterPlane);

        // ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ãƒ«ãƒ¼ãƒ—
        const animate = () => {
            requestAnimationFrame(animate);
            waterShader.uniforms.time.value += 0.02;
            renderer.render(scene, camera);
        };
        animate();
    </script>
</body>
</html>

-->


<!--  
<!DOCTYPE html>
 <html lang="en">
 <head>
     <meta charset="UTF-8">
     <meta name="viewport" content="width=device-width, initial-scale=1.0">
     <title>Abstract 2D Water Effect</title>
     <script type="importmap">
         {
             "imports": {
                 "three": "https://cdn.jsdelivr.net/npm/three@latest/build/three.module.min.js"
             }
         }
     </script>
 </head>
 <body>
     <script type="module">
         import * as THREE from 'three';
 
         // ã‚·ãƒ¼ãƒ³ã€ã‚«ãƒ¡ãƒ©ã€ãƒ¬ãƒ³ãƒ€ãƒ©ãƒ¼ã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
         const scene = new THREE.Scene();
         const camera = new THREE.OrthographicCamera(-5, 5, 5, -5, 1, 10);
         camera.position.z = 5;
 
         const renderer = new THREE.WebGLRenderer();
         renderer.setSize(window.innerWidth, window.innerHeight);
         document.body.appendChild(renderer.domElement);
 
         // ç¾åœ°å†™çœŸã®ãƒ­ãƒ¼ãƒ‰
         const textureLoader = new THREE.TextureLoader();
         const imageURL = './IMG_7940.JPG'; // ç¾åœ°å†™çœŸã®ãƒ‘ã‚¹
         const imageTexture = textureLoader.load(imageURL);
 
         // ã‚¨ãƒƒã‚¸æ¤œå‡º + æŠ½è±¡çš„ãªæ°´é¢ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼
         const waterShader = new THREE.ShaderMaterial({
             uniforms: {
                 time: { value: 0 },
                 texture1: { value: imageTexture },
                 resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) }
             },
             vertexShader: `
                 varying vec2 vUv;
                 void main() {
                     vUv = uv;
                     gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                 }
             `,
             fragmentShader: `
                 uniform float time;
                 uniform sampler2D texture1;
                 varying vec2 vUv;
 
                 // ã‚¨ãƒƒã‚¸æ¤œå‡ºï¼ˆSobelãƒ•ã‚£ãƒ«ã‚¿ï¼‰
                 float edgeDetection(vec2 uv) {
                     float offset = 0.002;
                     vec4 colX = texture2D(texture1, uv + vec2(-offset, 0.0)) - texture2D(texture1, uv + vec2(offset, 0.0));
                     vec4 colY = texture2D(texture1, uv + vec2(0.0, -offset)) - texture2D(texture1, uv + vec2(0.0, offset));
                     float edge = length(colX.rgb + colY.rgb);
                     return edge;
                 }
 
                 void main() {
                     // ã‚¨ãƒƒã‚¸å¼·åº¦ã‚’å–å¾—ï¼ˆ0ï½1ï¼‰
                     float edge = edgeDetection(vUv);
 
                     // æ°´é¢ã®å‹•ãï¼ˆã‚¨ãƒƒã‚¸ã«æ²¿ã£ã¦æºã‚‰ãï¼‰
                     float wave = sin(vUv.y * 10.0 + time + edge * 5.0) * 0.02;
                     vec2 distortedUV = vUv + vec2(wave, wave);
 
                     // æ°´ã®è‰²ã‚’CGçš„ã«ç”Ÿæˆï¼ˆã‚¨ãƒƒã‚¸ãŒå¼·ã„éƒ¨åˆ†ã»ã©å‹•ããŒå¤§ããè¦‹ãˆã‚‹ï¼‰
                     float waterPattern = sin(distortedUV.x * 20.0 + time) * cos(distortedUV.y * 20.0 + time);
                     vec3 waterColor = vec3(0.1, 0.4, 0.8) + waterPattern * 0.1;
 
                     // ã‚¨ãƒƒã‚¸ã‚’å¼·èª¿ã—ã¦æ°´ã®æµã‚Œã®æ¨¡æ§˜ã‚’ä½œã‚‹
                     waterColor += edge * vec3(0.5, 0.7, 1.0);
 
                     gl_FragColor = vec4(waterColor, 1.0);
                 }
             `
         });
 
         // æ°´é¢ã®æç”»
         const waterPlane = new THREE.Mesh(new THREE.PlaneGeometry(10, 10), waterShader);
         scene.add(waterPlane);
 
         // ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ãƒ«ãƒ¼ãƒ—
         const animate = () => {
             requestAnimationFrame(animate);
             waterShader.uniforms.time.value += 0.02;
             renderer.render(scene, camera);
         };
         animate();
     </script>
 </body>
 </html> 
 -->

 <!--
///æ°´æ»´ã«åå°„ã€€é™æ­¢ç”»

 <!DOCTYPE html>
 <html lang="en">
 <head>
     <meta charset="UTF-8">
     <meta name="viewport" content="width=device-width, initial-scale=1.0">
     <title>Water Droplets Effect</title>
     <script type="importmap">
         {
             "imports": {
                 "three": "https://cdn.jsdelivr.net/npm/three@latest/build/three.module.min.js"
             }
         }
     </script>
 </head>
 <body>
     <script type="module">
         import * as THREE from 'three';
 
         // ã‚·ãƒ¼ãƒ³ã€ã‚«ãƒ¡ãƒ©ã€ãƒ¬ãƒ³ãƒ€ãƒ©ãƒ¼ã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
         const scene = new THREE.Scene();
         const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
         camera.position.set(0, 0, 5);
 
         const renderer = new THREE.WebGLRenderer({ antialias: true });
         renderer.setSize(window.innerWidth, window.innerHeight);
         document.body.appendChild(renderer.domElement);
 
         // èƒŒæ™¯ç”»åƒã®ãƒ­ãƒ¼ãƒ‰
         const textureLoader = new THREE.TextureLoader();
         const imageURL = './IMG_7940.JPG';
         const backgroundTexture = textureLoader.load(imageURL, (texture) => {
             scene.background = texture;
         });
 
         // âœ… æ°´æ»´ã®ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒãƒ†ãƒªã‚¢ãƒ«
         const waterDropletShader = new THREE.ShaderMaterial({
             uniforms: {
                 backgroundTexture: { value: backgroundTexture },
                 time: { value: 0.0 }
             },
             vertexShader: `
                 varying vec2 vUv;
                 void main() {
                     vUv = uv;
                     vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                     gl_Position = projectionMatrix * mvPosition;
                 }
             `,
             fragmentShader: `
                 uniform sampler2D backgroundTexture;
                 uniform float time;
                 varying vec2 vUv;
 
                 // å±ˆæŠ˜ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
                 vec2 distortUV(vec2 uv, float strength) {
                     float wave = sin(uv.y * 20.0 + time) * 0.005;
                     return uv + vec2(wave, wave) * strength;
                 }
 
                 void main() {
                     // æ°´æ»´ã®ä¸­ã®ç”»åƒã‚’æ­ªã¾ã›ã‚‹
                     vec2 distortedUV = distortUV(vUv, 0.03);
                     vec4 color = texture2D(backgroundTexture, distortedUV);
 
                     // æ°´æ»´ã®è¼ªéƒ­ã‚’ã¼ã‹ã™
                     float edge = smoothstep(0.2, 0.4, abs(vUv.x - 0.5) + abs(vUv.y - 0.5));
                     color.rgb += edge * 0.5; // ã‚¨ãƒƒã‚¸éƒ¨åˆ†ã‚’æ˜ã‚‹ãã™ã‚‹
 
                     gl_FragColor = color;
                 }
             `,
             transparent: true
         });
 
         // âœ… æ°´æ»´ã‚’ä½œæˆ
         function createWaterDroplet(x, y, size) {
             const geometry = new THREE.SphereGeometry(size, 32, 32);
             const waterDroplet = new THREE.Mesh(geometry, waterDropletShader);
             waterDroplet.position.set(x, y, 0);
             scene.add(waterDroplet);
         }
 
         // âœ… è¤‡æ•°ã®æ°´æ»´ã‚’ãƒ©ãƒ³ãƒ€ãƒ ã«é…ç½®
         for (let i = 0; i < 15; i++) {
             createWaterDroplet((Math.random() - 0.5) * 4, (Math.random() - 0.5) * 4, Math.random() * 0.4 + 0.1);
         }
 
         // ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ãƒ«ãƒ¼ãƒ—
         function animate() {
             requestAnimationFrame(animate);
             waterDropletShader.uniforms.time.value += 0.01;
             renderer.render(scene, camera);
         }
         animate();
     </script>
 </body>
 </html>
 -->

 <!--
 ///æ°´æ»´ã«åå°„2 é™æ­¢ç”»

 <!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Water Droplets Effect</title>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@latest/build/three.module.min.js"
            }
        }
    </script>
</head>
<body>
    <script type="module">
        import * as THREE from 'three';

        // ã‚·ãƒ¼ãƒ³ã€ã‚«ãƒ¡ãƒ©ã€ãƒ¬ãƒ³ãƒ€ãƒ©ãƒ¼ã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 0, 5);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // èƒŒæ™¯ç”»åƒã®ãƒ­ãƒ¼ãƒ‰
        const textureLoader = new THREE.TextureLoader();
        const imageURL = './IMG_7940.JPG';
        const backgroundTexture = textureLoader.load(imageURL, (texture) => {
            scene.background = texture;
        });

        // âœ… æ°´æ»´ã®ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒãƒ†ãƒªã‚¢ãƒ«
        const waterDropletShader = new THREE.ShaderMaterial({
            uniforms: {
                backgroundTexture: { value: backgroundTexture },
                time: { value: 0.0 },
                randomRotation: { value: 0.0 },  // æ°´æ»´ã”ã¨ã®å›è»¢ã‚’ãƒ©ãƒ³ãƒ€ãƒ ã«
                randomDistortion: { value: 0.02 } // æ°´æ»´ã”ã¨ã®æ­ªã¿ã‚’ãƒ©ãƒ³ãƒ€ãƒ ã«
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                    gl_Position = projectionMatrix * mvPosition;
                }
            `,
            fragmentShader: `
                uniform sampler2D backgroundTexture;
                uniform float time;
                uniform float randomRotation;
                uniform float randomDistortion;
                varying vec2 vUv;

                // ãƒ©ãƒ³ãƒ€ãƒ ãªå›è»¢ã‚’é©ç”¨ã™ã‚‹é–¢æ•°
                vec2 rotateUV(vec2 uv, float angle) {
                    float s = sin(angle);
                    float c = cos(angle);
                    mat2 rotationMatrix = mat2(c, -s, s, c);
                    return (rotationMatrix * (uv - 0.5)) + 0.5;
                }

                // å±ˆæŠ˜ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
                vec2 distortUV(vec2 uv, float strength) {
                    float wave = sin(uv.y * 20.0 + time + randomRotation) * strength;
                    return uv + vec2(wave, wave) * randomDistortion;
                }

                void main() {
                    // æ°´æ»´ã®ä¸­ã®ç”»åƒã‚’ãƒ©ãƒ³ãƒ€ãƒ ãªè§’åº¦ã«å›è»¢
                    vec2 rotatedUV = rotateUV(vUv, randomRotation);
                    // æ°´æ»´ã®å†…éƒ¨ç”»åƒã‚’æ­ªã¾ã›ã‚‹
                    vec2 distortedUV = distortUV(rotatedUV, 0.03);
                    vec4 color = texture2D(backgroundTexture, distortedUV);

                    // æ°´æ»´ã®è¼ªéƒ­ã‚’ã¼ã‹ã™
                    float edge = smoothstep(0.2, 0.4, abs(vUv.x - 0.5) + abs(vUv.y - 0.5));
                    color.rgb += edge * 0.3; // ã‚¨ãƒƒã‚¸éƒ¨åˆ†ã‚’å°‘ã—æ˜ã‚‹ãã™ã‚‹

                    gl_FragColor = color;
                }
            `,
            transparent: true
        });

        // âœ… æ°´æ»´ã‚’ä½œæˆ
        function createWaterDroplet(x, y, size) {
            const geometry = new THREE.SphereGeometry(size, 32, 32);
            const material = waterDropletShader.clone(); // å„æ°´æ»´ã«ç•°ãªã‚‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’æŒãŸã›ã‚‹
            material.uniforms.randomRotation = { value: Math.random() * Math.PI * 2 }; // å›è»¢ã‚’ãƒ©ãƒ³ãƒ€ãƒ ã«
            material.uniforms.randomDistortion = { value: Math.random() * 0.03 + 0.02 }; // æ­ªã¿ã‚’ãƒ©ãƒ³ãƒ€ãƒ ã«

            const waterDroplet = new THREE.Mesh(geometry, material);
            waterDroplet.position.set(x, y, 0);
            scene.add(waterDroplet);
        }

        // âœ… è¤‡æ•°ã®æ°´æ»´ã‚’ãƒ©ãƒ³ãƒ€ãƒ ã«é…ç½®ï¼ˆãã‚Œãã‚Œç•°ãªã‚‹è§’åº¦ãƒ»æ­ªã¿ï¼‰
        for (let i = 0; i < 50; i++) {
            createWaterDroplet((Math.random() - 0.5) * 4, (Math.random() - 0.5) * 4, Math.random() * 0.3 + 0.1);
        }

        // ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ãƒ«ãƒ¼ãƒ—
        function animate() {
            requestAnimationFrame(animate);
            waterDropletShader.uniforms.time.value += 0.01;
            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>
</html>
-->

<!--
///æ°´æ»´ã«åå°„ å‹•ç”»ã€€åå°„

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dynamic Water Droplets</title>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@latest/build/three.module.min.js"
            }
        }
    </script>
</head>
<body>
    <script type="module">
        import * as THREE from 'three';

        // ã‚·ãƒ¼ãƒ³ã€ã‚«ãƒ¡ãƒ©ã€ãƒ¬ãƒ³ãƒ€ãƒ©ãƒ¼ã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 0, 5);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // èƒŒæ™¯ç”»åƒã®ãƒ­ãƒ¼ãƒ‰
        const textureLoader = new THREE.TextureLoader();
        const imageURL = './IMG_7948.JPG';
        const backgroundTexture = textureLoader.load(imageURL, (texture) => {
            scene.background = texture;
        });

        // æ°´æ»´ãƒ‡ãƒ¼ã‚¿
        let droplets = [];

        // âœ… æ°´æ»´ã®ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒãƒ†ãƒªã‚¢ãƒ«
        const waterDropletShader = new THREE.ShaderMaterial({
            uniforms: {
                backgroundTexture: { value: backgroundTexture },
                time: { value: 0.0 },
                dropletPosition: { value: new THREE.Vector2(0.0, 0.0) } // å„æ°´æ»´ã®ä½ç½®
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform sampler2D backgroundTexture;
                uniform float time;
                uniform vec2 dropletPosition;
                varying vec2 vUv;

                // å±ˆæŠ˜ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
                vec2 distortUV(vec2 uv, vec2 offset, float strength) {
                    float wave = sin(uv.y * 20.0 + time) * 0.005;
                    return uv + (offset - uv) * strength + vec2(wave, wave) * strength;
                }

                void main() {
                    // æ°´æ»´ã®ä½ç½®ã«å¿œã˜ãŸUVå¤‰æ›
                    vec2 newUV = vUv + (dropletPosition * 0.1);
                    
                    // èƒŒæ™¯ã®æ˜ ã‚Šè¾¼ã¿ã‚’å‹•çš„ã«å¤‰åŒ–
                    vec2 distortedUV = distortUV(newUV, dropletPosition, 0.05);
                    vec4 color = texture2D(backgroundTexture, distortedUV);

                    // æ°´æ»´ã®è¼ªéƒ­ã‚’ã¼ã‹ã™
                    float edge = smoothstep(0.2, 0.4, abs(vUv.x - 0.5) + abs(vUv.y - 0.5));
                    color.rgb += edge * 0.3;

                    gl_FragColor = color;
                }
            `,
            transparent: true
        });

        // âœ… æ°´æ»´ã‚’ä½œæˆ
        function createWaterDroplet(x, y, size) {
            const geometry = new THREE.SphereGeometry(size, 64, 64);
            const material = waterDropletShader.clone();
            material.uniforms.dropletPosition = { value: new THREE.Vector2(x, y) }; // å„æ°´æ»´ã«ä½ç½®æƒ…å ±ã‚’ä¸ãˆã‚‹

            const waterDroplet = new THREE.Mesh(geometry, material);
            waterDroplet.position.set(x, y, 0);

            // ãƒ©ãƒ³ãƒ€ãƒ ãªå‹•ãã®åˆæœŸåŒ–
            waterDroplet.velocity = new THREE.Vector2(
                (Math.random() - 0.5) * 0.01,
                (Math.random() - 0.5) * 0.01
            );
            waterDroplet.originalSize = size;
            droplets.push(waterDroplet);
            scene.add(waterDroplet);
        }

        // âœ… è¤‡æ•°ã®æ°´æ»´ã‚’ãƒ©ãƒ³ãƒ€ãƒ ã«é…ç½®
        for (let i = 0; i < 18; i++) {
            createWaterDroplet(
                (Math.random() - 0.5) * 4, 
                (Math.random() - 0.5) * 4, 
                Math.random() * 0.6 + 0.2
            );
        }

        // âœ… æ°´æ»´ã®å‹•ãã¨æ˜ ã‚Šè¾¼ã¿ã‚’æ›´æ–°ã™ã‚‹ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
        function updateDroplets() {
            for (let i = 0; i < droplets.length; i++) {
                let droplet = droplets[i];

                // ä½ç½®ã®æ›´æ–°
                droplet.position.x += droplet.velocity.x;
                droplet.position.y += droplet.velocity.y;

                // ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã«å‹•çš„ãªä½ç½®ã‚’æ¸¡ã™ï¼ˆæ˜ ã‚Šè¾¼ã¿ã®æ›´æ–°ï¼‰
                droplet.material.uniforms.dropletPosition.value.set(droplet.position.x, droplet.position.y);

                // æ°´æ»´ã®ã‚µã‚¤ã‚ºã‚’å¾®æŒ¯å‹•ã•ã›ã‚‹
                droplet.scale.setScalar(droplet.originalSize * (1 + 0.05 * Math.sin(performance.now() * 0.001)));

                // æ°´æ»´åŒå£«ã®å¼•ãåˆã„ãƒ»åç™º
                for (let j = i + 1; j < droplets.length; j++) {
                    let other = droplets[j];
                    let dx = other.position.x - droplet.position.x;
                    let dy = other.position.y - droplet.position.y;
                    let distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < 0.5) {
                        // è¿‘ã™ãã‚‹ã¨å°‘ã—é›¢ã‚Œã‚‹
                        droplet.velocity.x -= dx * 0.0005;
                        droplet.velocity.y -= dy * 0.0005;
                        other.velocity.x += dx * 0.0005;
                        other.velocity.y += dy * 0.0005;
                    } else if (distance < 1.0) {
                        // é©åº¦ãªè·é›¢ã«å¼•ãå¯„ã›ã‚‹
                        droplet.velocity.x += dx * 0.0002;
                        droplet.velocity.y += dy * 0.0002;
                        other.velocity.x -= dx * 0.0002;
                        other.velocity.y -= dy * 0.0002;
                    }
                }

                // é€Ÿåº¦ã®ãƒ©ãƒ³ãƒ€ãƒ å¤‰å‹•
                droplet.velocity.x += (Math.random() - 0.5) * 0.0005;
                droplet.velocity.y += (Math.random() - 0.5) * 0.0005;
                
                // ç”»é¢ç«¯ã§ãƒã‚¦ãƒ³ãƒ‰
                if (Math.abs(droplet.position.x) > 2) droplet.velocity.x *= -1;
                if (Math.abs(droplet.position.y) > 2) droplet.velocity.y *= -1;
            }
        }

        // âœ… ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ«ãƒ¼ãƒ—
        function animate() {
            requestAnimationFrame(animate);
            waterDropletShader.uniforms.time.value += 0.01;
            updateDroplets();
            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>
</html>
-->

<!--
///æ°´æ»´ã«åå°„ å‹•ç”»ã€€åå°„2

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multiple Moving Water Droplets with Reflections</title>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@latest/build/three.module.min.js"
            }
        }
    </script>
</head>
<body>
    <script type="module">
        import * as THREE from 'three';

        // ã‚·ãƒ¼ãƒ³ã€ã‚«ãƒ¡ãƒ©ã€ãƒ¬ãƒ³ãƒ€ãƒ©ãƒ¼ã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 0, 5);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // âœ… èƒŒæ™¯ç”»åƒã®ãƒ­ãƒ¼ãƒ‰ï¼ˆå‰Šé™¤ã›ãšãã®ã¾ã¾è¡¨ç¤ºï¼‰
        const textureLoader = new THREE.TextureLoader();
        const imageURL = './IMG_7940.JPG';
        const backgroundTexture = textureLoader.load(imageURL, (texture) => {
            scene.background = texture;
        });

        // âœ… æ°´æ»´ã®ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒãƒ†ãƒªã‚¢ãƒ«ï¼ˆèƒŒæ™¯ã‚’åå°„ï¼†å±ˆæŠ˜ã•ã›ã‚‹ï¼‰
        const waterDropletShader = new THREE.ShaderMaterial({
            uniforms: {
                backgroundTexture: { value: backgroundTexture },
                time: { value: 0.0 },
                dropletPosition: { value: new THREE.Vector2(0.0, 0.0) }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform sampler2D backgroundTexture;
                uniform float time;
                uniform vec2 dropletPosition;
                varying vec2 vUv;

                // æ°´æ»´ã®å†…éƒ¨ã«èƒŒæ™¯ã‚’å±ˆæŠ˜ã•ã›ã‚‹
                vec2 distortUV(vec2 uv, vec2 offset, float strength) {
                    float wave = sin(uv.y * 20.0 + time) * 0.005;
                    return uv + (offset - uv) * strength + vec2(wave, wave) * strength;
                }

                void main() {
                    vec2 distortedUV = distortUV(vUv, dropletPosition, 0.05);
                    vec4 color = texture2D(backgroundTexture, distortedUV);

                    // æ°´æ»´ã®è¼ªéƒ­ã‚’ã¼ã‹ã™
                    float edge = smoothstep(0.2, 0.4, abs(vUv.x - 0.5) + abs(vUv.y - 0.5));
                    color.rgb += edge * 0.3;

                    gl_FragColor = color;
                }
            `,
            transparent: true
        });

        // âœ… è¤‡æ•°ã®æ°´æ»´ã‚’ä½œæˆ
        let droplets = [];
        function createWaterDroplet(x, y, size) {
            const geometry = new THREE.SphereGeometry(size, 32, 32);
            const material = waterDropletShader.clone();
            material.uniforms.dropletPosition = { value: new THREE.Vector2(x, y) };

            const droplet = new THREE.Mesh(geometry, material);
            droplet.position.set(x, y, 0);

            droplet.velocity = new THREE.Vector2(
                (Math.random() - 0.5) * 0.02,
                (Math.random() - 0.5) * 0.02
            );
            droplet.timeOffset = Math.random() * 10; // ãƒ©ãƒ³ãƒ€ãƒ ãªæ™‚é–“ã‚ªãƒ•ã‚»ãƒƒãƒˆã§å‹•ãã‚’ãšã‚‰ã™
            droplets.push(droplet);
            scene.add(droplet);
        }

        // æ°´æ»´ã‚’ãƒ©ãƒ³ãƒ€ãƒ ã«é…ç½®
        for (let i = 0; i < 16; i++) {
            createWaterDroplet((Math.random() - 0.5) * 4, (Math.random() - 0.5) * 4, Math.random() * 0.3 + 0.1);
        }

        // âœ… ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ«ãƒ¼ãƒ—ï¼ˆæ›²ç·šçš„ãªãƒ©ãƒ³ãƒ€ãƒ ãªå‹•ãï¼‰
        let globalTime = 0;
        function animate() {
            requestAnimationFrame(animate);
            globalTime += 0.01;

            for (let droplet of droplets) {
                let t = globalTime + droplet.timeOffset;
                droplet.position.x = Math.sin(t * 0.5) * 2 + Math.sin(t * 0.3) * 1.5;
                droplet.position.y = Math.cos(t * 0.4) * 2 + Math.sin(t * 0.7) * 1.2;

                droplet.material.uniforms.dropletPosition.value.set(droplet.position.x, droplet.position.y);
            }

            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>
</html>
-->

<!--///æ°´æ»´ã«åå°„ å‹•ç”»ã€€åå°„3

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Water Droplets with Darker Background</title>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@latest/build/three.module.min.js"
            }
        }
    </script>
</head>
<body>
    <script type="module">
        import * as THREE from 'three';

        // ã‚·ãƒ¼ãƒ³ã€ã‚«ãƒ¡ãƒ©ã€ãƒ¬ãƒ³ãƒ€ãƒ©ãƒ¼ã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 0, 5);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.outputColorSpace = THREE.SRGBColorSpace; // âœ… WebGLã®sRGBå¤‰æ›ã‚’é©ç”¨
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // âœ… èƒŒæ™¯ç”»åƒã‚’æš—ã‚ã«ã™ã‚‹ãŸã‚ã®è¨­å®š
        const textureLoader = new THREE.TextureLoader();
        const imageURL = './IMG_7948.JPG';
        const backgroundTexture = textureLoader.load(imageURL, (texture) => {
            texture.colorSpace = THREE.SRGBColorSpace; // âœ… æ˜ã‚‹ã•è£œæ­£
        });

        // âœ… èƒŒæ™¯ã‚’ PlaneGeometry ã«é©ç”¨ã—ã€æš—ã‚ã®ãƒˆãƒ¼ãƒ³ã«èª¿æ•´
        const backgroundMaterial = new THREE.MeshBasicMaterial({
            map: backgroundTexture,
            opacity: 0.5,  // âœ… èƒŒæ™¯ã‚’å°‘ã—æš—ã‚ã«ã™ã‚‹ï¼ˆå€¤ã‚’ 0.5 ã€œ 1.0 ã§èª¿æ•´å¯èƒ½ï¼‰
            transparent: true
        });

        const backgroundPlane = new THREE.Mesh(new THREE.PlaneGeometry(10, 10), backgroundMaterial);
        backgroundPlane.position.set(0, 0, -1); // æ°´æ»´ã®å¥¥ã«é…ç½®
        scene.add(backgroundPlane);

        // âœ… æ°´æ»´ã®ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒãƒ†ãƒªã‚¢ãƒ«ï¼ˆå†…éƒ¨ã®åå°„ã‚’æ˜ã‚‹ãã™ã‚‹ï¼‰
        const waterDropletShader = new THREE.ShaderMaterial({
            uniforms: {
                backgroundTexture: { value: backgroundTexture },
                dropletPosition: { value: new THREE.Vector2(0.0, 0.0) },
                time: { value: 0.0 }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform sampler2D backgroundTexture;
                uniform vec2 dropletPosition;
                uniform float time;
                varying vec2 vUv;

                // æ°´æ»´ã®å†…éƒ¨ã®åå°„ã‚’æ­ªã¾ã›ã‚‹
                vec2 distortUV(vec2 uv, vec2 offset, float strength) {
                    float wave = sin(time + uv.x * 10.0) * 0.02;
                    return uv + (offset - uv) * strength + vec2(wave, wave);
                }

                void main() {
                    // èƒŒæ™¯ç”»åƒã®UVã‚’å–å¾—ã—ã€å†…éƒ¨ã‚’å±ˆæŠ˜ã•ã›ã‚‹
                    vec2 distortedUV = distortUV(vUv, dropletPosition, 0.08);
                    vec4 color = texture2D(backgroundTexture, distortedUV);

                    // âœ… æ°´æ»´ã®å†…éƒ¨ã®åå°„ã‚’ç™½ã£ã½ãæ˜ã‚‹ãã™ã‚‹
                    color.rgb = mix(color.rgb, vec3(1.0), 0.1); // 10% ç™½ã«å¯„ã›ã‚‹

                    // âœ… ã‚¨ãƒƒã‚¸éƒ¨åˆ†ã‚’å°‘ã—å¼·èª¿ï¼ˆé€æ˜æ„Ÿã®è¡¨ç¾ï¼‰
                    float edge = smoothstep(0.3, 0.5, length(vUv - vec2(0.5, 0.5)));
                    color.rgb += edge * 0.2;

                    gl_FragColor = color;
                }
            `,
            transparent: true
        });

        // âœ… è¤‡æ•°ã®æ°´æ»´ã‚’ä½œæˆ
        let droplets = [];
        function createWaterDroplet(x, y, size) {
            const geometry = new THREE.SphereGeometry(size, 32, 32);
            const material = waterDropletShader.clone();
            material.uniforms.dropletPosition = { value: new THREE.Vector2(x, y) };

            const droplet = new THREE.Mesh(geometry, material);
            droplet.position.set(x, y, 0);

            droplet.timeOffset = Math.random() * 10; // å€‹åˆ¥ã®å‹•ãã‚’æŒãŸã›ã‚‹
            droplets.push(droplet);
            scene.add(droplet);
        }

        // æ°´æ»´ã‚’ãƒ©ãƒ³ãƒ€ãƒ ã«é…ç½®
        for (let i = 0; i < 30; i++) {
            createWaterDroplet((Math.random() - 0.5) * 4, (Math.random() - 0.5) * 4, Math.random() * 0.3 + 0.1);
        }

        // âœ… ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ«ãƒ¼ãƒ—ï¼ˆæ›²ç·šçš„ãªãƒ©ãƒ³ãƒ€ãƒ ãªå‹•ãï¼‰
        let globalTime = 0;
        function animate() {
            requestAnimationFrame(animate);
            globalTime += 0.01;

            for (let droplet of droplets) {
                let t = globalTime + droplet.timeOffset;
                droplet.position.x = Math.sin(t * 0.5) * 2 + Math.sin(t * 0.3) * 1.5;
                droplet.position.y = Math.cos(t * 0.4) * 2 + Math.sin(t * 0.7) * 1.2;

                // âœ… æ°´æ»´ã®ã‚µã‚¤ã‚ºã‚’æ™‚é–“ã¨ã¨ã‚‚ã«å¤‰åŒ–ï¼ˆå‘¼å¸ã™ã‚‹ã‚ˆã†ãªå‹•ãï¼‰
                droplet.scale.setScalar(1.2 + 0.2 * Math.sin(globalTime * 2));

                // æ°´æ»´ã®ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã«å‹•çš„ãªä½ç½®ã‚’æ¸¡ã™
                droplet.material.uniforms.dropletPosition.value.set(droplet.position.x, droplet.position.y);
                droplet.material.uniforms.time.value = globalTime;
            }

            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>
</html>
-->


<!--æµ®éŠ

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Floating Water Droplets (Bounded & Color Fixed)</title>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@latest/build/three.module.min.js"
            }
        }
    </script>
</head>
<body>
    <script type="module">
        import * as THREE from 'three';

        // ã‚·ãƒ¼ãƒ³ã€ã‚«ãƒ¡ãƒ©ã€ãƒ¬ãƒ³ãƒ€ãƒ©ãƒ¼ã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 0, 5);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // âœ… èƒŒæ™¯ç”»åƒã®é©ç”¨
        const textureLoader = new THREE.TextureLoader();
        const imageURL = './IMG_7940.JPG';
        const backgroundTexture = textureLoader.load(imageURL);
        
        const backgroundMaterial = new THREE.MeshBasicMaterial({ map: backgroundTexture });
        const backgroundPlane = new THREE.Mesh(new THREE.PlaneGeometry(8, 8), backgroundMaterial);
        backgroundPlane.position.set(0, 0, -1);
        scene.add(backgroundPlane);

        // âœ… èƒŒæ™¯å†™çœŸã®ç¯„å›²ã‚’å–å¾—
        const boundX = backgroundPlane.geometry.parameters.width / 2 - 0.5;  // âœ… æ°´æ»´ãŒã¯ã¿å‡ºã•ãªã„ã‚ˆã†ã«èª¿æ•´
        const boundY = backgroundPlane.geometry.parameters.height / 2 - 0.5;

        // âœ… æ°´æ»´ã®ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒãƒ†ãƒªã‚¢ãƒ«ï¼ˆå‹•çš„ãªæ­ªã¿ & è‰²å¤‰åŒ–ï¼‰
        const waterDropletShader = new THREE.ShaderMaterial({
            uniforms: {
                backgroundTexture: { value: backgroundTexture },
                dropletPosition: { value: new THREE.Vector2(0.0, 0.0) },
                time: { value: 0.0 },
                distortionStrength: { value: 0.08 },
                dropletColor: { value: new THREE.Color() }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform sampler2D backgroundTexture;
                uniform vec2 dropletPosition;
                uniform float time;
                uniform float distortionStrength;
                uniform vec3 dropletColor;
                varying vec2 vUv;

                // æ°´æ»´ã®å†…éƒ¨ã®åå°„ã‚’æ­ªã¾ã›ã‚‹
                vec2 distortUV(vec2 uv, vec2 offset, float strength) {
                    float wave = sin(time * 5.0 + uv.x * 15.0) * strength;
                    return uv + (offset - uv) * strength + vec2(wave, wave);
                }

                void main() {
                    // èƒŒæ™¯ç”»åƒã®UVã‚’å–å¾—ã—ã€å†…éƒ¨ã‚’å±ˆæŠ˜ã•ã›ã‚‹
                    vec2 distortedUV = distortUV(vUv, dropletPosition, distortionStrength);
                    vec4 color = texture2D(backgroundTexture, distortedUV);

                    // âœ… æ°´æ»´ã®è‰²ã‚’é©ç”¨
                    color.rgb = mix(color.rgb, dropletColor, 0.5);

                    // âœ… æ°´æ»´ã®è¼ªéƒ­ã‚’ã«ã˜ã¾ã›ã‚‹
                    float edge = smoothstep(0.4, 0.6, length(vUv - vec2(0.5, 0.5)));
                    color.a = mix(1.0, 0.0, edge); // å¤–å´ã‚’é€æ˜ã«

                    gl_FragColor = color;
                }
            `,
            transparent: true
        });

        // âœ… æ°´æ»´ã‚’ä½œæˆï¼ˆç¯„å›²å†…ã«åã‚ã‚‹ & è‰²ã‚’ä¿®æ­£ï¼‰
        let droplets = [];
        function createWaterDroplet(x, y, size, index) {
            const geometry = new THREE.SphereGeometry(size, 32, 32);
            const material = waterDropletShader.clone();
            material.uniforms.dropletPosition = { value: new THREE.Vector2(x, y) };
            
            // âœ… ãƒ©ãƒ³ãƒ€ãƒ ãªæ˜ã‚‹ã„è‰²ï¼ˆé»’ã«ãªã‚‰ãªã„ã‚ˆã†ã«ï¼‰
            material.uniforms.dropletColor.value = new THREE.Color(
                //0.5 + Math.random() * 0.5, 
                //0.5 + Math.random() * 0.5, 
                //0.5 + Math.random() * 0.5
                Math.random(), 
                Math.random(), 
                Math.random()


            );

            const droplet = new THREE.Mesh(geometry, material);
            droplet.position.set(x, y, 0);

            // âœ… ã‚†ã£ãã‚Šæµ®ãå‹•ã
            droplet.velocity = new THREE.Vector3(
                (Math.random() - 0.5) * 0.005, 
                (Math.random() - 0.5) * 0.005, 
                0
            );
            droplet.index = index;

            droplets.push(droplet);
            scene.add(droplet);
        }

        // âœ… æ°´æ»´ã‚’ãƒ©ãƒ³ãƒ€ãƒ ã«é…ç½®ï¼ˆèƒŒæ™¯å†™çœŸã®ç¯„å›²å†…ã«åˆ¶é™ï¼‰
        for (let i = 0; i < 100; i++) {
            createWaterDroplet((Math.random() - 0.5) * boundX * 1.5, (Math.random() - 0.5) * boundY * 1.5, Math.random() * 0.3 + 0.1, i);
        }

        // âœ… ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ«ãƒ¼ãƒ—ï¼ˆç¯„å›²åˆ¶é™ & æµ®éŠæ„Ÿã‚’æœ€å„ªå…ˆï¼‰
        let globalTime = 0;
        function animate() {
            requestAnimationFrame(animate);
            globalTime += 0.01;

            droplets.forEach((droplet) => {
                let pos = droplet.position;
                let vel = droplet.velocity;

                // âœ… ç”»é¢ç«¯ã§ã®è·³ã­è¿”ã‚Šï¼ˆã¯ã¿å‡ºã—è£œæ­£ï¼‰
                if (pos.x > boundX) { pos.x = boundX; vel.x *= -0.8; }
                if (pos.x < -boundX) { pos.x = -boundX; vel.x *= -0.8; }
                if (pos.y > boundY) { pos.y = boundY; vel.y *= -0.8; }
                if (pos.y < -boundY) { pos.y = -boundY; vel.y *= -0.8; }

                pos.add(vel);

                // âœ… ã‚†ã£ãã‚Šæ¸›é€Ÿã—ã€æ»‘ã‚‰ã‹ã«å‹•ã
                // vel.multiplyScalar(0.998);

                // âœ… ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã®ä½ç½®æƒ…å ±ã‚’æ›´æ–°
                droplet.material.uniforms.dropletPosition.value.set(pos.x, pos.y);
                droplet.material.uniforms.time.value = globalTime;
            });

            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>
</html>
-->

<!--ã€€ãƒ—ãƒ¬ãƒ¼ãƒˆåå°„ã€€ãƒ¢ãƒã‚¯ãƒ­
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Floating Reflective Plates</title>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@latest/build/three.module.min.js"
            }
        }
    </script>
</head>
<body>
    <script type="module">
        import * as THREE from 'three';

        // ã‚·ãƒ¼ãƒ³ã€ã‚«ãƒ¡ãƒ©ã€ãƒ¬ãƒ³ãƒ€ãƒ©ãƒ¼ã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 0, 5);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // èƒŒæ™¯ç”»åƒã‚’ãƒ­ãƒ¼ãƒ‰ã—ã¦ãƒ¢ãƒã‚¯ãƒ­åŒ–
        const textureLoader = new THREE.TextureLoader();
        textureLoader.load('./IMG_7948.JPG', (texture) => {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');

            canvas.width = texture.image.width;
            canvas.height = texture.image.height;
            ctx.drawImage(texture.image, 0, 0);

            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            for (let i = 0; i < imageData.data.length; i += 4) {
                let gray = 0.299 * imageData.data[i] + 0.587 * imageData.data[i + 1] + 0.114 * imageData.data[i + 2];
                imageData.data[i] = gray;
                imageData.data[i + 1] = gray;
                imageData.data[i + 2] = gray;
            }
            ctx.putImageData(imageData, 0, 0);
            const grayscaleTexture = new THREE.CanvasTexture(canvas);

            // èƒŒæ™¯ã®é©ç”¨
            const backgroundMaterial = new THREE.MeshBasicMaterial({ map: grayscaleTexture });
            const backgroundPlane = new THREE.Mesh(new THREE.PlaneGeometry(8, 8), backgroundMaterial);
            backgroundPlane.position.set(0, 0, -1);
            scene.add(backgroundPlane);

            // ç’°å¢ƒãƒãƒƒãƒ—ã®ä½œæˆï¼ˆåå°„ç”¨ï¼‰
            const cubeRenderTarget = new THREE.WebGLCubeRenderTarget(512, { format: THREE.RGBAFormat });
            const cubeCamera = new THREE.CubeCamera(0.1, 100, cubeRenderTarget);
            scene.add(cubeCamera);

            // åå°„ç”¨ã®ç‰©ç†ãƒãƒ†ãƒªã‚¢ãƒ«ï¼ˆå…‰æ²¢ã‚’å¼·åŒ–ï¼‰
            const reflectiveMaterial = new THREE.MeshPhysicalMaterial({
                envMap: cubeRenderTarget.texture, // èƒŒæ™¯ç”»åƒã‚’åå°„
                metalness: 0.9,
                roughness: 0.05, // å°‘ã—ã ã‘ç²—ã•ã‚’å…¥ã‚Œã‚‹
                clearcoat: 1.0,  // åå°„ã‚’å¼·åŒ–
                clearcoatRoughness: 0.02,
                envMapIntensity: 1.2 // åå°„ã‚’å¼·èª¿
            });

            // ãƒ—ãƒ¬ãƒ¼ãƒˆã®ä½œæˆ
            let plates = [];
            function createReflectivePlate(x, y, size, index) {
                const geometry = new THREE.PlaneGeometry(size, size);
                const material = reflectiveMaterial.clone();
                const plate = new THREE.Mesh(geometry, material);

                plate.position.set(x, y, 0);
                plate.rotation.y = Math.random() * Math.PI * 2;
                plate.rotation.x = Math.random() * Math.PI * 2;
                plate.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.01,
                    (Math.random() - 0.5) * 0.01,
                    0
                );
                plate.index = index;

                plates.push(plate);
                scene.add(plate);
            }

            // èƒŒæ™¯ã®ç¯„å›²ã«åˆ¶é™ã—ã¦ãƒ—ãƒ¬ãƒ¼ãƒˆã‚’é…ç½®
            const boundX = backgroundPlane.geometry.parameters.width / 2 - 0.5;
            const boundY = backgroundPlane.geometry.parameters.height / 2 - 0.5;

            for (let i = 0; i < 100; i++) {
                createReflectivePlate(
                    (Math.random() - 0.5) * boundX * 1.5,
                    (Math.random() - 0.5) * boundY * 1.5,
                    Math.random() * 0.3 + 0.1,
                    i
                );
            }

            // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ«ãƒ¼ãƒ—
            let globalTime = 0;
            function animate() {
                requestAnimationFrame(animate);
                globalTime += 0.01;

                plates.forEach((plate) => {
                    let pos = plate.position;
                    let vel = plate.velocity;

                    // ç”»é¢ç«¯ã§ã®è·³ã­è¿”ã‚Š
                    if (pos.x > boundX) { pos.x = boundX; vel.x *= -1; }
                    if (pos.x < -boundX) { pos.x = -boundX; vel.x *= -1; }
                    if (pos.y > boundY) { pos.y = boundY; vel.y *= -1; }
                    if (pos.y < -boundY) { pos.y = -boundY; vel.y *= -1; }

                    pos.add(vel);
                    plate.rotation.x += 0.01;
                    plate.rotation.y += 0.01;
                });

                // ãƒ—ãƒ¬ãƒ¼ãƒˆã®åå°„ã‚’ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æ›´æ–°
                cubeCamera.update(renderer, scene);

                renderer.render(scene, camera);
            }
            animate();
        });

    </script>
</body>
</html>
-->

<!--ã€€ãƒ—ãƒ¬ãƒ¼ãƒˆ1æšåå°„ã‚«ãƒ©ãƒ¼ã€€èƒŒæ™¯ãƒ¢ãƒã‚¯ãƒ­
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Reflective Square Plate with Monochrome Background</title>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@latest/build/three.module.min.js"
            }
        }
    </script>
</head>
<body>
    <script type="module">
        import * as THREE from 'three';

        // ã‚·ãƒ¼ãƒ³ã€ã‚«ãƒ¡ãƒ©ã€ãƒ¬ãƒ³ãƒ€ãƒ©ãƒ¼ã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 0, 5);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // ç”»åƒã®èª­ã¿è¾¼ã¿
        const textureLoader = new THREE.TextureLoader();
        textureLoader.load('./IMG_7940.JPG', (originalTexture) => {
            const imgWidth = originalTexture.image.width;
            const imgHeight = originalTexture.image.height;
            const aspectRatio = imgWidth / imgHeight;

            // ğŸ¨ **èƒŒæ™¯ã‚’ãƒ¢ãƒã‚¯ãƒ­åŒ–**
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = imgWidth;
            canvas.height = imgHeight;
            ctx.drawImage(originalTexture.image, 0, 0);

            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            for (let i = 0; i < imageData.data.length; i += 4) {
                let gray = 0.299 * imageData.data[i] + 0.587 * imageData.data[i + 1] + 0.114 * imageData.data[i + 2];
                imageData.data[i] = gray;
                imageData.data[i + 1] = gray;
                imageData.data[i + 2] = gray;
            }
            ctx.putImageData(imageData, 0, 0);
            const grayscaleTexture = new THREE.CanvasTexture(canvas);

            // **èƒŒæ™¯ã‚µã‚¤ã‚ºã‚’ç”»é¢å†…ã«åã‚ã‚‹**
            const bgScale = Math.min(window.innerWidth / imgWidth, window.innerHeight / imgHeight);
            const bgGeometry = new THREE.PlaneGeometry(imgWidth * bgScale * 0.01, imgHeight * bgScale * 0.01);

            // **ãƒ¢ãƒã‚¯ãƒ­èƒŒæ™¯ã‚’ä½œæˆ**
            const backgroundMaterial = new THREE.MeshBasicMaterial({ map: grayscaleTexture });
            const backgroundPlane = new THREE.Mesh(bgGeometry, backgroundMaterial);
            backgroundPlane.position.set(0, 0, -2);
            scene.add(backgroundPlane);

            // **åå°„ç”¨ã®CubeCamera**
            const cubeRenderTarget = new THREE.WebGLCubeRenderTarget(512, { format: THREE.RGBAFormat });
            const cubeCamera = new THREE.CubeCamera(0.1, 100, cubeRenderTarget);
            scene.add(cubeCamera);

            // **ãƒ—ãƒ¬ãƒ¼ãƒˆã®åå°„ã‚’ã‚«ãƒ©ãƒ¼ã®ã¿ã«ã™ã‚‹ãŸã‚ã€ä¸€æ™‚çš„ã«ã‚·ãƒ¼ãƒ³èƒŒæ™¯ã‚’ã‚«ãƒ©ãƒ¼ç”»åƒã«å¤‰æ›´**
            function updateReflection() {
                const originalBackground = scene.background;
                scene.background = originalTexture; // ä¸€æ™‚çš„ã«ã‚«ãƒ©ãƒ¼èƒŒæ™¯ã‚’è¨­å®š
                backgroundPlane.visible = false; // ãƒ¢ãƒã‚¯ãƒ­èƒŒæ™¯ã‚’ä¸€æ™‚çš„ã«éš ã™
                cubeCamera.update(renderer, scene); // ã‚«ãƒ©ãƒ¼èƒŒæ™¯ã®ã¿ã‚’ã‚­ãƒ£ãƒ—ãƒãƒ£
                backgroundPlane.visible = true; // ãƒ¢ãƒã‚¯ãƒ­èƒŒæ™¯ã‚’å†è¡¨ç¤º
                scene.background = originalBackground; // å…ƒã®ãƒ¢ãƒã‚¯ãƒ­èƒŒæ™¯ã«æˆ»ã™
            }

            // ğŸ¨ **ãƒ—ãƒ¬ãƒ¼ãƒˆã®åå°„ã‚’ã‚«ãƒ©ãƒ¼ã«ã™ã‚‹**
            const reflectiveMaterial = new THREE.MeshPhysicalMaterial({
                envMap: cubeRenderTarget.texture,
                metalness: 1.0, 
                roughness: 0.05, 
                reflectivity: 1.0, 
                clearcoat: 1.0,  
                clearcoatRoughness: 0.02,
                envMapIntensity: 1.5
            });

            // **ãƒ—ãƒ¬ãƒ¼ãƒˆã®ã‚µã‚¤ã‚ºã‚’æ­£æ–¹å½¢ã«**
            const plateSize = bgScale * 5; // ç”»é¢ã‚µã‚¤ã‚ºã«é©ã—ãŸã‚¹ã‚±ãƒ¼ãƒ«
            const plateGeometry = new THREE.PlaneGeometry(plateSize, plateSize);
            const plate = new THREE.Mesh(plateGeometry, reflectiveMaterial);
            plate.position.set(0, 0, -0.5);
            scene.add(plate);

            // **ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ«ãƒ¼ãƒ—**
            function animate() {
                requestAnimationFrame(animate);

                // **ãƒ—ãƒ¬ãƒ¼ãƒˆã®ã‚†ã‚‹ã‚„ã‹ãªå›è»¢**
                plate.rotation.x += 0.005;
                plate.rotation.y += 0.005;

                // **ãƒ—ãƒ¬ãƒ¼ãƒˆã®åå°„ã‚’ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æ›´æ–°**
                updateReflection();

                renderer.render(scene, camera);
            }

            // **åˆå›ã‚­ãƒ£ãƒ—ãƒãƒ£**
            updateReflection();
            renderer.render(scene, camera);

            animate();
        });

    </script>
</body>
</html>
-->

<!--ç«‹æ–¹ä½“6é¢åå°„
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Reflective Cube with Monochrome Background</title>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@latest/build/three.module.min.js"
            }
        }
    </script>
</head>
<body>
    <script type="module">
        import * as THREE from 'three';

        // ã‚·ãƒ¼ãƒ³ã€ã‚«ãƒ¡ãƒ©ã€ãƒ¬ãƒ³ãƒ€ãƒ©ãƒ¼ã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 0, 5);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // ç”»åƒã®èª­ã¿è¾¼ã¿
        const textureLoader = new THREE.TextureLoader();
        textureLoader.load('./IMG_7948.JPG', (originalTexture) => {
            const imgWidth = originalTexture.image.width;
            const imgHeight = originalTexture.image.height;
            const aspectRatio = imgWidth / imgHeight;

            // ğŸ¨ **èƒŒæ™¯ã‚’ãƒ¢ãƒã‚¯ãƒ­åŒ–**
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = imgWidth;
            canvas.height = imgHeight;
            ctx.drawImage(originalTexture.image, 0, 0);

            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            for (let i = 0; i < imageData.data.length; i += 4) {
                let gray = 0.299 * imageData.data[i] + 0.587 * imageData.data[i + 1] + 0.114 * imageData.data[i + 2];
                imageData.data[i] = gray;
                imageData.data[i + 1] = gray;
                imageData.data[i + 2] = gray;
            }
            ctx.putImageData(imageData, 0, 0);
            const grayscaleTexture = new THREE.CanvasTexture(canvas);

            // **èƒŒæ™¯ã‚µã‚¤ã‚ºã‚’ç”»é¢å†…ã«åã‚ã‚‹**
            const bgScale = Math.min(window.innerWidth / imgWidth, window.innerHeight / imgHeight);
            const bgGeometry = new THREE.PlaneGeometry(imgWidth * bgScale * 0.01, imgHeight * bgScale * 0.01);

            // **ãƒ¢ãƒã‚¯ãƒ­èƒŒæ™¯ã‚’ä½œæˆ**
            const backgroundMaterial = new THREE.MeshBasicMaterial({ map: grayscaleTexture });
            const backgroundPlane = new THREE.Mesh(bgGeometry, backgroundMaterial);
            backgroundPlane.position.set(0, 0, -2);
            scene.add(backgroundPlane);

            // **åå°„ç”¨ã®CubeCamera**
            const cubeRenderTarget = new THREE.WebGLCubeRenderTarget(1024, { format: THREE.RGBAFormat });
            const cubeCamera = new THREE.CubeCamera(0.1, 100, cubeRenderTarget);
            scene.add(cubeCamera);

            // **ç«‹æ–¹ä½“ã®ã‚µã‚¤ã‚º**
            const cubeSize = bgScale * 5;
            const cubeGeometry = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize);

            // **ç«‹æ–¹ä½“ã®åå°„ã‚’é©ç”¨**
            const reflectiveMaterial = new THREE.MeshPhysicalMaterial({
                metalness: 0.8,
                roughness: 0,
                reflectivity: 1.0,
                clearcoat: 1.0,
                clearcoatRoughness: 0.02,
                envMapIntensity: 1.2,
                side: THREE.DoubleSide
            });

            const cube = new THREE.Mesh(cubeGeometry, reflectiveMaterial);
            cube.position.set(0, 0, 0);
            scene.add(cube);

            // **ç«‹æ–¹ä½“ã®åå°„ã‚’ç¢ºå®Ÿã«é©ç”¨**
            function updateReflection() {
                scene.background = originalTexture;  // ã‚«ãƒ©ãƒ¼èƒŒæ™¯ã«å¤‰æ›´
                backgroundPlane.visible = false;     // ãƒ¢ãƒã‚¯ãƒ­èƒŒæ™¯ã‚’éš ã™
                cube.visible = false;                // ç«‹æ–¹ä½“ã‚’ä¸€æ™‚çš„ã«éš ã™
                cubeCamera.update(renderer, scene);  // ç’°å¢ƒãƒãƒƒãƒ—ã‚’æ›´æ–°
                cube.material.envMap = cubeRenderTarget.texture; // åå°„ã‚’é©ç”¨
                cube.material.needsUpdate = true;    // ãƒãƒ†ãƒªã‚¢ãƒ«ã‚’æ›´æ–°
                cube.visible = true;                 // ç«‹æ–¹ä½“ã‚’å†è¡¨ç¤º
                scene.background = null;             // èƒŒæ™¯ã‚’å…ƒã«æˆ»ã™
                backgroundPlane.visible = true;      // ãƒ¢ãƒã‚¯ãƒ­èƒŒæ™¯ã‚’å†è¡¨ç¤º
            }

            // **ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ«ãƒ¼ãƒ—**
            function animate() {
                requestAnimationFrame(animate);

                cube.rotation.x += 0.005;
                cube.rotation.y += 0.005;

                updateReflection();

                renderer.render(scene, camera);
            }

            updateReflection();
            renderer.render(scene, camera);

            animate();
        });

    </script>
</body>
</html>
-->

<!--ç«‹æ–¹ä½“åå°„6é¢ã€€
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Reflective Cube with Sharp Reflections</title>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@latest/build/three.module.min.js"
            }
        }
    </script>
</head>
<body>
    <script type="module">
        import * as THREE from 'three';

        // ã‚·ãƒ¼ãƒ³ã€ã‚«ãƒ¡ãƒ©ã€ãƒ¬ãƒ³ãƒ€ãƒ©ãƒ¼ã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 0, 5);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // ç”»åƒã®èª­ã¿è¾¼ã¿
        const textureLoader = new THREE.TextureLoader();
        textureLoader.load('./IMG_7940.JPG', (originalTexture) => {
            const imgWidth = originalTexture.image.width;
            const imgHeight = originalTexture.image.height;
            const aspectRatio = imgWidth / imgHeight;

            // ğŸ¨ **èƒŒæ™¯ã‚’ãƒ¢ãƒã‚¯ãƒ­åŒ–**
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = imgWidth;
            canvas.height = imgHeight;
            ctx.drawImage(originalTexture.image, 0, 0);

            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            for (let i = 0; i < imageData.data.length; i += 4) {
                let gray = 0.299 * imageData.data[i] + 0.587 * imageData.data[i + 1] + 0.114 * imageData.data[i + 2];
                imageData.data[i] = gray;
                imageData.data[i + 1] = gray;
                imageData.data[i + 2] = gray;
            }
            ctx.putImageData(imageData, 0, 0);
            const grayscaleTexture = new THREE.CanvasTexture(canvas);

            // **èƒŒæ™¯ã‚µã‚¤ã‚ºã‚’ç”»é¢å†…ã«åã‚ã‚‹**
            const bgScale = Math.min(window.innerWidth / imgWidth, window.innerHeight / imgHeight);
            const bgGeometry = new THREE.PlaneGeometry(imgWidth * bgScale * 0.01, imgHeight * bgScale * 0.01);

            // **ãƒ¢ãƒã‚¯ãƒ­èƒŒæ™¯ã‚’ä½œæˆ**
            const backgroundMaterial = new THREE.MeshBasicMaterial({ map: grayscaleTexture });
            const backgroundPlane = new THREE.Mesh(bgGeometry, backgroundMaterial);
            backgroundPlane.position.set(0, 0, -2);
            scene.add(backgroundPlane);

            // **åå°„ç”¨ã®CubeCamera**
            const cubeRenderTarget = new THREE.WebGLCubeRenderTarget(2048, { format: THREE.RGBAFormat });
            const cubeCamera = new THREE.CubeCamera(0.1, 100, cubeRenderTarget);
            scene.add(cubeCamera);

            // **ç«‹æ–¹ä½“ã®ã‚µã‚¤ã‚º**
            const cubeSize = bgScale * 5;
            const cubeGeometry = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize);

            // **ç«‹æ–¹ä½“ã®åå°„ã‚’é©ç”¨**
            const reflectiveMaterial = new THREE.MeshPhysicalMaterial({
                metalness: 1.0,
                roughness: 0.0, // ã‚·ãƒ£ãƒ¼ãƒ—ãªåå°„ã®ãŸã‚ 0 ã«ã™ã‚‹
                reflectivity: 1.0,
                clearcoat: 1.0,
                clearcoatRoughness: 0.0, // ã‚¯ãƒªã‚¢ãªåå°„ã®ãŸã‚ 0 ã«ã™ã‚‹
                envMapIntensity: 2.0, // åå°„ã‚’å¼·èª¿
                side: THREE.DoubleSide
            });

            const cube = new THREE.Mesh(cubeGeometry, reflectiveMaterial);
            cube.position.set(0, 0, 0);
            scene.add(cube);

            // **ç«‹æ–¹ä½“ã®åå°„ã‚’ç¢ºå®Ÿã«é©ç”¨**
            function updateReflection() {
                scene.background = originalTexture;  // ã‚«ãƒ©ãƒ¼èƒŒæ™¯ã«å¤‰æ›´
                backgroundPlane.visible = false;     // ãƒ¢ãƒã‚¯ãƒ­èƒŒæ™¯ã‚’éš ã™
                cube.visible = false;                // ç«‹æ–¹ä½“ã‚’ä¸€æ™‚çš„ã«éš ã™
                cubeCamera.update(renderer, scene);  // ç’°å¢ƒãƒãƒƒãƒ—ã‚’æ›´æ–°
                cube.material.envMap = cubeRenderTarget.texture; // åå°„ã‚’é©ç”¨
                cube.material.needsUpdate = true;    // ãƒãƒ†ãƒªã‚¢ãƒ«ã‚’æ›´æ–°
                cube.visible = true;                 // ç«‹æ–¹ä½“ã‚’å†è¡¨ç¤º
                scene.background = null;             // èƒŒæ™¯ã‚’å…ƒã«æˆ»ã™
                backgroundPlane.visible = true;      // ãƒ¢ãƒã‚¯ãƒ­èƒŒæ™¯ã‚’å†è¡¨ç¤º
            }

            // **ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ«ãƒ¼ãƒ—**
            function animate() {
                requestAnimationFrame(animate);

                cube.rotation.x += 0.005;
                cube.rotation.y += 0.005;

                updateReflection();

                renderer.render(scene, camera);
            }

            updateReflection();
            renderer.render(scene, camera);

            animate();
        });

    </script>
</body>
</html>
-->

<!-- ç«‹æ–¹ä½“è½ä¸‹
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rolling and Reflective Fractal Cubes</title>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@latest/build/three.module.min.js"
            }
        }
    </script>
</head>
<body>
    <script type="module">
        import * as THREE from 'three';

        // ã‚·ãƒ¼ãƒ³ã€ã‚«ãƒ¡ãƒ©ã€ãƒ¬ãƒ³ãƒ€ãƒ©ãƒ¼ã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 5, 12);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // ç”»åƒã®èª­ã¿è¾¼ã¿
        const textureLoader = new THREE.TextureLoader();
        textureLoader.load('./IMG_7940.JPG', (originalTexture) => {
            const imgWidth = originalTexture.image.width;
            const imgHeight = originalTexture.image.height;

            // **èƒŒæ™¯ã‚’ãƒ¢ãƒã‚¯ãƒ­åŒ–**
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = imgWidth;
            canvas.height = imgHeight;
            ctx.drawImage(originalTexture.image, 0, 0);

            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            for (let i = 0; i < imageData.data.length; i += 4) {
                let gray = 0.299 * imageData.data[i] + 0.587 * imageData.data[i + 1] + 0.114 * imageData.data[i + 2];
                imageData.data[i] = gray;
                imageData.data[i + 1] = gray;
                imageData.data[i + 2] = gray;
            }
            ctx.putImageData(imageData, 0, 0);
            const grayscaleTexture = new THREE.CanvasTexture(canvas);

            // **èƒŒæ™¯ã‚’è¨­å®š**
            scene.background = grayscaleTexture;

            // **åå°„ç”¨ã®CubeCamera**
            const cubeRenderTarget = new THREE.WebGLCubeRenderTarget(2048, { format: THREE.RGBAFormat });
            const cubeCamera = new THREE.CubeCamera(0.1, 100, cubeRenderTarget);
            scene.add(cubeCamera);

            // **ç«‹æ–¹ä½“ã®ãƒãƒ†ãƒªã‚¢ãƒ«**
            const createMaterial = () => new THREE.MeshPhysicalMaterial({
                metalness: 1.0,
                roughness: 0.1,
                reflectivity: 1.0,
                clearcoat: 1.0,
                clearcoatRoughness: 0.1,
                envMapIntensity: 2.0,
                side: THREE.DoubleSide
            });

            // **ç«‹æ–¹ä½“ã‚¯ãƒ©ã‚¹**
            class RollingCube {
                constructor(size, position, velocity, angularVelocity) {
                    this.size = size;
                    this.mesh = new THREE.Mesh(new THREE.BoxGeometry(size, size, size), createMaterial());
                    this.mesh.position.copy(position);
                    scene.add(this.mesh);

                    this.velocity = velocity;
                    this.angularVelocity = angularVelocity;
                    this.split = false;
                }

                update() {
                    if (this.mesh.position.y > 0) {
                        this.velocity.y -= 0.002; // é‡åŠ›
                        this.mesh.position.add(this.velocity);
                        this.mesh.rotation.x += this.angularVelocity.x;
                        this.mesh.rotation.y += this.angularVelocity.y;
                        this.mesh.rotation.z += this.angularVelocity.z;
                    } else {
                        if (!this.split && this.size > 0.3) {
                            this.split = true;
                            this.splitCube();
                        }

                        // **è»¢ãŒã‚‹å‹•ãã‚’å†ç¾**
                        this.velocity.x *= 0.98;
                        this.velocity.z *= 0.98;
                        this.angularVelocity.multiplyScalar(0.98);

                        if (this.velocity.length() < 0.01 && this.angularVelocity.length() < 0.01) {
                            this.velocity.set(0, 0, 0);
                            this.angularVelocity.set(0, 0, 0);
                            this.snapToGround();
                        }
                    }
                }

                splitCube() {
                    for (let i = 0; i < 4; i++) {
                        const offset = new THREE.Vector3(
                            (Math.random() - 0.5) * this.size,
                            0.1,
                            (Math.random() - 0.5) * this.size
                        );
                        const newCube = new RollingCube(
                            this.size * 0.5,
                            this.mesh.position.clone().add(offset),
                            new THREE.Vector3(
                                (Math.random() - 0.5) * 0.1,
                                Math.random() * 0.1 + 0.05,
                                (Math.random() - 0.5) * 0.1
                            ),
                            new THREE.Vector3(
                                (Math.random() - 0.5) * 0.1,
                                (Math.random() - 0.5) * 0.1,
                                (Math.random() - 0.5) * 0.1
                            )
                        );
                        cubes.push(newCube);
                    }
                }

                snapToGround() {
                    this.mesh.rotation.x = Math.round(this.mesh.rotation.x / (Math.PI / 2)) * (Math.PI / 2);
                    this.mesh.rotation.y = Math.round(this.mesh.rotation.y / (Math.PI / 2)) * (Math.PI / 2);
                    this.mesh.rotation.z = Math.round(this.mesh.rotation.z / (Math.PI / 2)) * (Math.PI / 2);
                }
            }

            let cubes = [];
            cubes.push(new RollingCube(
                1.0,
                new THREE.Vector3(0, 8, 0),
                new THREE.Vector3(0, -0.05, 0),
                new THREE.Vector3(0.05, 0.03, 0.02)
            ));

            function updateReflection() {
                cubes.forEach(cube => cube.mesh.visible = false);
                cubeCamera.update(renderer, scene);
                cubes.forEach(cube => {
                    cube.mesh.visible = true;
                    cube.mesh.material.envMap = cubeRenderTarget.texture;
                    cube.mesh.material.needsUpdate = true;
                });
            }

            function animate() {
                requestAnimationFrame(animate);
                cubes.forEach(cube => cube.update());
                updateReflection();
                renderer.render(scene, camera);
            }

            animate();
        });
    </script>
</body>
</html>
-->

<!--ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã€€çƒä½“åå°„
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Refractive Sphere with Color Reflection</title>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@latest/build/three.module.min.js"
            }
        }
    </script>
</head>
<body>
    <script type="module">
        import * as THREE from 'three';

        // **ã‚·ãƒ¼ãƒ³ã€ã‚«ãƒ¡ãƒ©ã€ãƒ¬ãƒ³ãƒ€ãƒ©ãƒ¼ã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—**
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 0, 5);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const textureLoader = new THREE.TextureLoader();

        // **èƒŒæ™¯ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’ãƒ­ãƒ¼ãƒ‰**
        textureLoader.load('./abstract_image1.png', (backgroundTexture) => {
            backgroundTexture.colorSpace = THREE.SRGBColorSpace;

            // **ãƒ¢ãƒã‚¯ãƒ­åŒ–ã—ãŸèƒŒæ™¯ç”¨ã® CanvasTexture ã‚’ä½œæˆ**
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = backgroundTexture.image.width;
            canvas.height = backgroundTexture.image.height;
            ctx.drawImage(backgroundTexture.image, 0, 0);

            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            for (let i = 0; i < imageData.data.length; i += 4) {
                let gray = 0.299 * imageData.data[i] + 0.587 * imageData.data[i + 1] + 0.114 * imageData.data[i + 2];
                imageData.data[i] = gray;
                imageData.data[i + 1] = gray;
                imageData.data[i + 2] = gray;
            }
            ctx.putImageData(imageData, 0, 0);
            const grayscaleTexture = new THREE.CanvasTexture(canvas);

            // **èƒŒæ™¯ã‚’ãƒ¢ãƒã‚¯ãƒ­ã«è¨­å®š**
            scene.background = grayscaleTexture;

            // **æ³•ç·šãƒãƒƒãƒ—ï¼ˆçƒä½“ã®æ›²é¢ã®å½±éŸ¿ã‚’å†ç¾ã™ã‚‹ãŸã‚ï¼‰**
            const normalMap = textureLoader.load('https://threejs.org/examples/textures/waternormals.jpg');
            normalMap.wrapS = normalMap.wrapT = THREE.RepeatWrapping;

            // **ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒãƒ†ãƒªã‚¢ãƒ«ã‚’ä½œæˆ**
            const refractiveShader = new THREE.ShaderMaterial({
                uniforms: {
                    backgroundTexture: { value: backgroundTexture }, // **ã‚«ãƒ©ãƒ¼åå°„ç”¨**
                    grayscaleTexture: { value: grayscaleTexture },  // **ãƒ¢ãƒã‚¯ãƒ­èƒŒæ™¯ç”¨**
                    normalMap: { value: normalMap },
                    refractionStrength: { value: 0.03 }, // **å±ˆæŠ˜ã®å¼·ã•**
                    brightness: { value: 1.5 }, // **æ˜ã‚‹ã•è£œæ­£**
                    uCameraPosition: { value: camera.position } // **ã‚«ãƒ¡ãƒ©ã®ä½ç½®**
                },
                vertexShader: `
                    varying vec3 vNormal;
                    varying vec3 vViewPosition;
                    varying vec2 vUv;
                    
                    void main() {
                        vNormal = normalize(normalMatrix * normal);
                        vViewPosition = (modelViewMatrix * vec4(position, 1.0)).xyz;
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform sampler2D backgroundTexture; // ã‚«ãƒ©ãƒ¼åå°„ç”¨
                    uniform sampler2D grayscaleTexture;  // ãƒ¢ãƒã‚¯ãƒ­èƒŒæ™¯ç”¨
                    uniform sampler2D normalMap;
                    uniform float refractionStrength;
                    uniform float brightness;
                    uniform vec3 uCameraPosition;
                    varying vec3 vNormal;
                    varying vec3 vViewPosition;
                    varying vec2 vUv;

                    void main() {
                        // **æ³•ç·šãƒãƒƒãƒ—ã‚’é©ç”¨**
                        vec3 normalColor = texture2D(normalMap, vUv * 2.0).rgb * 2.0 - 1.0;
                        vec3 normal = normalize(vNormal + normalColor * 0.2);

                        // **è¦–ç‚¹æ–¹å‘ã¨æ³•ç·šã®è¨ˆç®—**
                        vec3 viewDir = normalize(uCameraPosition - vViewPosition);
                        vec3 refractDir = refract(viewDir, normal, refractionStrength);

                        // **åå°„ç”¨ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’ã‚«ãƒ©ãƒ¼ã§å–å¾—**
                        vec2 refractedUV = vUv + refractDir.xy * 0.1;
                        vec4 reflectionColor = texture2D(backgroundTexture, refractedUV);

                        // **æ˜ã‚‹ã•è£œæ­£**
                        reflectionColor.rgb *= brightness;

                        // **æœ€çµ‚ã‚«ãƒ©ãƒ¼ã‚’é©ç”¨**
                        gl_FragColor = vec4(reflectionColor.rgb, 1.0);
                    }
                `,
                transparent: true
            });

            // **çƒä½“ã‚’ä½œæˆ**
            const sphereGeometry = new THREE.SphereGeometry(1, 128, 128);
            const sphere = new THREE.Mesh(sphereGeometry, refractiveShader);
            scene.add(sphere);

            // **ç…§æ˜ã‚’è¿½åŠ ï¼ˆç’°å¢ƒå…‰ï¼‰**
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(5, 5, 5);
            scene.add(directionalLight);

            // **å›è»¢é€Ÿåº¦ã‚’è¨­å®š**
            let rotationSpeedX = 0.005;
            let rotationSpeedY = 0.007;

            // **ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ«ãƒ¼ãƒ—**
            function animate() {
                requestAnimationFrame(animate);

                // **çƒä½“ã‚’å›è»¢**
                sphere.rotation.x += rotationSpeedX;
                sphere.rotation.y += rotationSpeedY;

                // **ã‚«ãƒ¡ãƒ©ä½ç½®ã‚’çƒã®å›è»¢ã«å¿œã˜ã¦æ›´æ–°**
                refractiveShader.uniforms.uCameraPosition.value.copy(camera.position);

                renderer.render(scene, camera);
            }

            animate();
        });

    </script>
</body>
</html>
-->

<!--ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã€€ç«‹æ–¹ä½“åå°„
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Refractive Cube with Color Reflection</title>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@latest/build/three.module.min.js"
            }
        }
    </script>
</head>
<body>
    <script type="module">
        import * as THREE from 'three';

        // **ã‚·ãƒ¼ãƒ³ã€ã‚«ãƒ¡ãƒ©ã€ãƒ¬ãƒ³ãƒ€ãƒ©ãƒ¼ã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—**
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 0, 5);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const textureLoader = new THREE.TextureLoader();

        // **èƒŒæ™¯ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’ãƒ­ãƒ¼ãƒ‰**
        textureLoader.load('./abstract_image1.png', (backgroundTexture) => {
            backgroundTexture.colorSpace = THREE.SRGBColorSpace;

            // **ãƒ¢ãƒã‚¯ãƒ­åŒ–ã—ãŸèƒŒæ™¯ç”¨ã® CanvasTexture ã‚’ä½œæˆ**
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = backgroundTexture.image.width;
            canvas.height = backgroundTexture.image.height;
            ctx.drawImage(backgroundTexture.image, 0, 0);

            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            for (let i = 0; i < imageData.data.length; i += 4) {
                let gray = 0.299 * imageData.data[i] + 0.587 * imageData.data[i + 1] + 0.114 * imageData.data[i + 2];
                imageData.data[i] = gray;
                imageData.data[i + 1] = gray;
                imageData.data[i + 2] = gray;
            }
            ctx.putImageData(imageData, 0, 0);
            const grayscaleTexture = new THREE.CanvasTexture(canvas);

            // **èƒŒæ™¯ã‚’ãƒ¢ãƒã‚¯ãƒ­ã«è¨­å®š**
            scene.background = grayscaleTexture;

            // **æ³•ç·šãƒãƒƒãƒ—ï¼ˆç«‹æ–¹ä½“ã®è¡¨é¢ã®å¤‰åŒ–ã‚’å†ç¾ã™ã‚‹ãŸã‚ï¼‰**
            const normalMap = textureLoader.load('https://threejs.org/examples/textures/waternormals.jpg');
            normalMap.wrapS = normalMap.wrapT = THREE.RepeatWrapping;

            // **ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒãƒ†ãƒªã‚¢ãƒ«ã‚’ä½œæˆ**
            const refractiveShader = new THREE.ShaderMaterial({
                uniforms: {
                    backgroundTexture: { value: backgroundTexture }, // **ã‚«ãƒ©ãƒ¼åå°„ç”¨**
                    grayscaleTexture: { value: grayscaleTexture },  // **ãƒ¢ãƒã‚¯ãƒ­èƒŒæ™¯ç”¨**
                    normalMap: { value: normalMap },
                    refractionStrength: { value: 0.05 }, // **ç«‹æ–¹ä½“ãªã®ã§å±ˆæŠ˜ã‚’å¼·ã‚ã«**
                    brightness: { value: 1.8 }, // **æ˜ã‚‹ã•è£œæ­£**
                    uCameraPosition: { value: camera.position } // **ã‚«ãƒ¡ãƒ©ã®ä½ç½®**
                },
                vertexShader: `
                    varying vec3 vNormal;
                    varying vec3 vViewPosition;
                    varying vec2 vUv;
                    
                    void main() {
                        vNormal = normalize(normalMatrix * normal);
                        vViewPosition = (modelViewMatrix * vec4(position, 1.0)).xyz;
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform sampler2D backgroundTexture; // ã‚«ãƒ©ãƒ¼åå°„ç”¨
                    uniform sampler2D grayscaleTexture;  // ãƒ¢ãƒã‚¯ãƒ­èƒŒæ™¯ç”¨
                    uniform sampler2D normalMap;
                    uniform float refractionStrength;
                    uniform float brightness;
                    uniform vec3 uCameraPosition;
                    varying vec3 vNormal;
                    varying vec3 vViewPosition;
                    varying vec2 vUv;

                    void main() {
                        // **æ³•ç·šãƒãƒƒãƒ—ã‚’é©ç”¨**
                        vec3 normalColor = texture2D(normalMap, vUv * 2.0).rgb * 2.0 - 1.0;
                        vec3 normal = normalize(vNormal + normalColor * 0.3);

                        // **è¦–ç‚¹æ–¹å‘ã¨æ³•ç·šã®è¨ˆç®—**
                        vec3 viewDir = normalize(uCameraPosition - vViewPosition);
                        vec3 refractDir = refract(viewDir, normal, refractionStrength);

                        // **åå°„ç”¨ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’ã‚«ãƒ©ãƒ¼ã§å–å¾—**
                        vec2 refractedUV = vUv + refractDir.xy * 0.15;
                        vec4 reflectionColor = texture2D(backgroundTexture, refractedUV);

                        // **æ˜ã‚‹ã•è£œæ­£**
                        reflectionColor.rgb *= brightness;

                        // **æœ€çµ‚ã‚«ãƒ©ãƒ¼ã‚’é©ç”¨**
                        gl_FragColor = vec4(reflectionColor.rgb, 1.0);
                    }
                `,
                transparent: true
            });

            // **ç«‹æ–¹ä½“ã‚’ä½œæˆ**
            const cubeGeometry = new THREE.BoxGeometry(1.5, 1.5, 1.5, 64, 64, 64); // åˆ†å‰²æ•°ã‚’å¢—ã‚„ã—ã¦ãªã‚ã‚‰ã‹ã«
            const cube = new THREE.Mesh(cubeGeometry, refractiveShader);
            scene.add(cube);

            // **ç…§æ˜ã‚’è¿½åŠ ï¼ˆç’°å¢ƒå…‰ï¼‰**
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(5, 5, 5);
            scene.add(directionalLight);

            // **å›è»¢é€Ÿåº¦ã‚’è¨­å®š**
            let rotationSpeedX = 0.005;
            let rotationSpeedY = 0.007;

            // **ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ«ãƒ¼ãƒ—**
            function animate() {
                requestAnimationFrame(animate);

                // **ç«‹æ–¹ä½“ã‚’å›è»¢**
                cube.rotation.x += rotationSpeedX;
                cube.rotation.y += rotationSpeedY;

                // **ã‚«ãƒ¡ãƒ©ä½ç½®ã‚’ç«‹æ–¹ä½“ã®å›è»¢ã«å¿œã˜ã¦æ›´æ–°**
                refractiveShader.uniforms.uCameraPosition.value.copy(camera.position);

                renderer.render(scene, camera);
            }

            animate();
        });

    </script>
</body>
</html>
-->


<!--å…«é¢ä½“ã€€åå°„
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Refractive Octahedron with Color Reflection</title>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@latest/build/three.module.min.js"
            }
        }
    </script>
</head>
<body>
    <script type="module">
        import * as THREE from 'three';

        // **ã‚·ãƒ¼ãƒ³ã€ã‚«ãƒ¡ãƒ©ã€ãƒ¬ãƒ³ãƒ€ãƒ©ãƒ¼ã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—**
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 0, 5);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const textureLoader = new THREE.TextureLoader();

        // **èƒŒæ™¯ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’ãƒ­ãƒ¼ãƒ‰**
        textureLoader.load('./abstract_image_pastel.png', (backgroundTexture) => {
            backgroundTexture.colorSpace = THREE.SRGBColorSpace;

            // **ãƒ¢ãƒã‚¯ãƒ­åŒ–ã—ãŸèƒŒæ™¯ç”¨ã® CanvasTexture ã‚’ä½œæˆ**
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = backgroundTexture.image.width;
            canvas.height = backgroundTexture.image.height;
            ctx.drawImage(backgroundTexture.image, 0, 0);

            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            for (let i = 0; i < imageData.data.length; i += 4) {
                let gray = 0.299 * imageData.data[i] + 0.587 * imageData.data[i + 1] + 0.114 * imageData.data[i + 2];
                imageData.data[i] = gray;
                imageData.data[i + 1] = gray;
                imageData.data[i + 2] = gray;
            }
            ctx.putImageData(imageData, 0, 0);
            const grayscaleTexture = new THREE.CanvasTexture(canvas);

            // **èƒŒæ™¯ã‚’ãƒ¢ãƒã‚¯ãƒ­ã«è¨­å®š**
            scene.background = grayscaleTexture;

            // **æ³•ç·šãƒãƒƒãƒ—**
            const normalMap = textureLoader.load('https://threejs.org/examples/textures/waternormals.jpg');
            normalMap.wrapS = normalMap.wrapT = THREE.RepeatWrapping;

            // **ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒãƒ†ãƒªã‚¢ãƒ«ã‚’ä½œæˆ**
            const refractiveShader = new THREE.ShaderMaterial({
                uniforms: {
                    backgroundTexture: { value: backgroundTexture },
                    grayscaleTexture: { value: grayscaleTexture },
                    normalMap: { value: normalMap },
                    refractionStrength: { value: 0.08 }, // **å±ˆæŠ˜ã‚’å¼·ãã™ã‚‹**
                    brightness: { value: 2.0 }, // **æ˜ã‚‹ã•è£œæ­£**
                    uCameraPosition: { value: camera.position }
                },
                vertexShader: `
                    varying vec3 vNormal;
                    varying vec3 vViewPosition;
                    varying vec2 vUv;
                    
                    void main() {
                        vNormal = normalize(normalMatrix * normal);
                        vViewPosition = (modelViewMatrix * vec4(position, 1.0)).xyz;
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform sampler2D backgroundTexture;
                    uniform sampler2D grayscaleTexture;
                    uniform sampler2D normalMap;
                    uniform float refractionStrength;
                    uniform float brightness;
                    uniform vec3 uCameraPosition;
                    varying vec3 vNormal;
                    varying vec3 vViewPosition;
                    varying vec2 vUv;

                    void main() {
                        vec3 normalColor = texture2D(normalMap, vUv * 2.0).rgb * 2.0 - 1.0;
                        vec3 normal = normalize(vNormal + normalColor * 0.3);

                        vec3 viewDir = normalize(uCameraPosition - vViewPosition);
                        vec3 refractDir = refract(viewDir, normal, refractionStrength);

                        vec2 refractedUV = vUv + refractDir.xy * 0.2;
                        vec4 reflectionColor = texture2D(backgroundTexture, refractedUV);

                        reflectionColor.rgb *= brightness;

                        gl_FragColor = vec4(reflectionColor.rgb, 1.0);
                    }
                `,
                transparent: true
            });

            const octahedron = new THREE.Mesh(new THREE.OctahedronGeometry(1.5, 1), refractiveShader);
            scene.add(octahedron);

            function animate() {
                requestAnimationFrame(animate);
                octahedron.rotation.x += 0.005;
                octahedron.rotation.y += 0.007;
                renderer.render(scene, camera);
            }

            animate();
        });
    </script>
</body>
</html>
-->


<!--ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã€€ãƒ—ãƒ¬ãƒ¼ãƒˆï¼ˆå›ºå®šã€åšã¿0ï¼‰
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dynamic Reflective Plane</title>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@latest/build/three.module.min.js"
            }
        }
    </script>
</head>
<body>
    <script type="module">
        import * as THREE from 'three';

        // **ã‚·ãƒ¼ãƒ³ã€ã‚«ãƒ¡ãƒ©ã€ãƒ¬ãƒ³ãƒ€ãƒ©ãƒ¼ã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—**
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 0, 5);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const textureLoader = new THREE.TextureLoader();

        // **èƒŒæ™¯ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’ãƒ­ãƒ¼ãƒ‰**
        textureLoader.load('./abstract_image2.png', (backgroundTexture) => {
            backgroundTexture.colorSpace = THREE.SRGBColorSpace;

            // **ãƒ¢ãƒã‚¯ãƒ­åŒ–ã—ãŸèƒŒæ™¯ç”¨ã® CanvasTexture ã‚’ä½œæˆ**
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = backgroundTexture.image.width;
            canvas.height = backgroundTexture.image.height;
            ctx.drawImage(backgroundTexture.image, 0, 0);

            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            for (let i = 0; i < imageData.data.length; i += 4) {
                let gray = 0.299 * imageData.data[i] + 0.587 * imageData.data[i + 1] + 0.114 * imageData.data[i + 2];
                imageData.data[i] = gray;
                imageData.data[i + 1] = gray;
                imageData.data[i + 2] = gray;
            }
            ctx.putImageData(imageData, 0, 0);
            const grayscaleTexture = new THREE.CanvasTexture(canvas);

            // **èƒŒæ™¯ã‚’ãƒ¢ãƒã‚¯ãƒ­ã«è¨­å®š**
            scene.background = grayscaleTexture;

            // **æ³•ç·šãƒãƒƒãƒ—**
            const normalMap = textureLoader.load('https://threejs.org/examples/textures/waternormals.jpg');
            normalMap.wrapS = normalMap.wrapT = THREE.RepeatWrapping;

            // **ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒãƒ†ãƒªã‚¢ãƒ«ã‚’ä½œæˆ**
            const refractiveShader = new THREE.ShaderMaterial({
                uniforms: {
                    backgroundTexture: { value: backgroundTexture },
                    grayscaleTexture: { value: grayscaleTexture },
                    normalMap: { value: normalMap },
                    refractionStrength: { value: 0.05 },
                    brightness: { value: 1.8 },
                    uCameraPosition: { value: camera.position },
                    uPlanePosition: { value: new THREE.Vector3() }  // **ãƒ—ãƒ¬ãƒ¼ãƒˆã®ä½ç½®ã‚’ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã«æ¸¡ã™**
                },
                vertexShader: `
                    varying vec3 vNormal;
                    varying vec3 vViewPosition;
                    varying vec2 vUv;
                    
                    void main() {
                        vNormal = normalize(normalMatrix * normal);
                        vViewPosition = (modelViewMatrix * vec4(position, 1.0)).xyz;
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform sampler2D backgroundTexture;
                    uniform sampler2D grayscaleTexture;
                    uniform sampler2D normalMap;
                    uniform float refractionStrength;
                    uniform float brightness;
                    uniform vec3 uCameraPosition;
                    uniform vec3 uPlanePosition;
                    varying vec3 vNormal;
                    varying vec3 vViewPosition;
                    varying vec2 vUv;

                    void main() {
                        vec3 normalColor = texture2D(normalMap, vUv * 3.0).rgb * 2.0 - 1.0;
                        vec3 normal = normalize(vNormal + normalColor * 0.15);

                        vec3 viewDir = normalize(uCameraPosition - vViewPosition);
                        vec3 refractDir = refract(viewDir, normal, refractionStrength);

                        // **ãƒ—ãƒ¬ãƒ¼ãƒˆã®ä½ç½®ã«å¿œã˜ã¦å‹•çš„ãªåå°„ã‚’é©ç”¨**
                        vec2 refractedUV = vUv + refractDir.xy * 0.08 + (uPlanePosition.xy * 0.05);
                        vec4 reflectionColor = texture2D(backgroundTexture, refractedUV);

                        reflectionColor.rgb *= brightness;

                        gl_FragColor = vec4(reflectionColor.rgb, 1.0);
                    }
                `,
                transparent: true
            });

            // **ãƒ—ãƒ¬ãƒ¼ãƒˆ (å¹³é¢) ã‚’ä½œæˆ**
            const planeGeometry = new THREE.PlaneGeometry(3, 3, 64, 64);
            const plane = new THREE.Mesh(planeGeometry, refractiveShader);
            plane.position.set(0, 0, 0);
            scene.add(plane);

            // **ç…§æ˜ã‚’è¿½åŠ ï¼ˆç’°å¢ƒå…‰ï¼‰**
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(5, 5, 5);
            scene.add(directionalLight);

            // **å›è»¢é€Ÿåº¦ã‚’è¨­å®š**
            let rotationSpeedX = 0.003;
            let rotationSpeedY = 0.004;

            // **ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ«ãƒ¼ãƒ—**
            function animate() {
                requestAnimationFrame(animate);

                // **ãƒ—ãƒ¬ãƒ¼ãƒˆã‚’å›è»¢**
                plane.rotation.x += rotationSpeedX;
                plane.rotation.y += rotationSpeedY;

                // **ãƒ—ãƒ¬ãƒ¼ãƒˆã®ä½ç½®ã‚’ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã«æ¸¡ã™**
                refractiveShader.uniforms.uPlanePosition.value.copy(plane.position);

                // **ã‚«ãƒ¡ãƒ©ä½ç½®ã‚’ãƒ—ãƒ¬ãƒ¼ãƒˆã®å›è»¢ã«å¿œã˜ã¦æ›´æ–°**
                refractiveShader.uniforms.uCameraPosition.value.copy(camera.position);

                renderer.render(scene, camera);
            }

            animate();
        });

    </script>
</body>
</html>
-->

<!--æ­£æ–¹å½¢ãƒ—ãƒ¬ãƒ¼ãƒˆ
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Reflective Thick Plate</title>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@latest/build/three.module.min.js"
            }
        }
    </script>
</head>
<body>
    <script type="module">
        import * as THREE from 'three';

        // **ã‚·ãƒ¼ãƒ³ã€ã‚«ãƒ¡ãƒ©ã€ãƒ¬ãƒ³ãƒ€ãƒ©ãƒ¼ã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—**
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 0, 5);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const textureLoader = new THREE.TextureLoader();

        // **èƒŒæ™¯ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’ãƒ­ãƒ¼ãƒ‰**
        textureLoader.load('./abstract_water_style.png', (backgroundTexture) => {
            backgroundTexture.colorSpace = THREE.SRGBColorSpace;

            // **ãƒ¢ãƒã‚¯ãƒ­åŒ–ã—ãŸèƒŒæ™¯ç”¨ã® CanvasTexture ã‚’ä½œæˆ**
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = backgroundTexture.image.width;
            canvas.height = backgroundTexture.image.height;
            ctx.drawImage(backgroundTexture.image, 0, 0);

            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            for (let i = 0; i < imageData.data.length; i += 4) {
                let gray = 0.299 * imageData.data[i] + 0.587 * imageData.data[i + 1] + 0.114 * imageData.data[i + 2];
                imageData.data[i] = gray;
                imageData.data[i + 1] = gray;
                imageData.data[i + 2] = gray;
            }
            ctx.putImageData(imageData, 0, 0);
            const grayscaleTexture = new THREE.CanvasTexture(canvas);

            // **èƒŒæ™¯ã‚’ãƒ¢ãƒã‚¯ãƒ­ã«è¨­å®š**
            scene.background = grayscaleTexture;

            // **åå°„ãƒãƒ†ãƒªã‚¢ãƒ«ã®ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼**
            const reflectiveShader = new THREE.ShaderMaterial({
                uniforms: {
                    backgroundTexture: { value: backgroundTexture },
                    uCameraPosition: { value: camera.position }
                },
                vertexShader: `
                    varying vec3 vNormal;
                    varying vec3 vViewPosition;
                    varying vec2 vUv;
                    
                    void main() {
                        vNormal = normalize(normalMatrix * normal);
                        vViewPosition = (modelViewMatrix * vec4(position, 1.0)).xyz;
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform sampler2D backgroundTexture;
                    uniform vec3 uCameraPosition;
                    varying vec3 vNormal;
                    varying vec3 vViewPosition;
                    varying vec2 vUv;

                    void main() {
                        // **ã‚«ãƒ¡ãƒ©ã‹ã‚‰ãƒ—ãƒ¬ãƒ¼ãƒˆè¡¨é¢ã®åå°„æ–¹å‘ã‚’è¨ˆç®—**
                        vec3 viewDir = normalize(uCameraPosition - vViewPosition);
                        vec3 reflectDir = reflect(viewDir, normalize(vNormal));

                        // **åå°„ã‚’UVãƒãƒƒãƒ”ãƒ³ã‚°**
                        vec2 reflectedUV = vUv + reflectDir.xy * 0.2;
                        vec4 reflectionColor = texture2D(backgroundTexture, reflectedUV);

                        gl_FragColor = vec4(reflectionColor.rgb, 1.0);
                    }
                `,
                side: THREE.DoubleSide, // **è¡¨è£ä¸¡é¢ã«åå°„ã‚’é©ç”¨**
                transparent: true
            });

            // **åšã¿ã®ã‚ã‚‹ãƒ—ãƒ¬ãƒ¼ãƒˆã‚’ä½œæˆ**
            const plateGeometry = new THREE.BoxGeometry(2, 2, 0.1); // **åšã¿ 0.1 ã‚’è¿½åŠ **
            const plate = new THREE.Mesh(plateGeometry, reflectiveShader);
            plate.position.set(0, 0, 0);
            scene.add(plate);

            // **ç…§æ˜ã‚’è¿½åŠ ï¼ˆç’°å¢ƒå…‰ï¼‰**
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(5, 5, 5);
            scene.add(directionalLight);

            // **å›è»¢é€Ÿåº¦ã‚’è¨­å®š**
            let rotationSpeedX = 0.005;
            let rotationSpeedY = 0.008;

            // **ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ«ãƒ¼ãƒ—**
            function animate() {
                requestAnimationFrame(animate);

                // **ãƒ—ãƒ¬ãƒ¼ãƒˆã‚’å›è»¢**
                plate.rotation.x += rotationSpeedX;
                plate.rotation.y += rotationSpeedY;

                // **ã‚«ãƒ¡ãƒ©ä½ç½®ã‚’ãƒ—ãƒ¬ãƒ¼ãƒˆã®å›è»¢ã«å¿œã˜ã¦æ›´æ–°**
                reflectiveShader.uniforms.uCameraPosition.value.copy(camera.position);

                renderer.render(scene, camera);
            }

            animate();
        });

    </script>
</body>
</html>
-->

<!--ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼çƒä½“ã€€ã‚¤ãƒ³ãƒ—ãƒƒãƒˆç”»åƒ2ã¤
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Refractive Sphere with Separate Background & Reflection</title>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@latest/build/three.module.min.js"
            }
        }
    </script>
</head>
<body>
    <script type="module">
        import * as THREE from 'three';

        // **ã‚·ãƒ¼ãƒ³ã€ã‚«ãƒ¡ãƒ©ã€ãƒ¬ãƒ³ãƒ€ãƒ©ãƒ¼ã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—**
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 0, 5);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const textureLoader = new THREE.TextureLoader();

        // **ç”»åƒãƒ•ã‚¡ã‚¤ãƒ«ã‚’æŒ‡å®š**
        const backgroundImagePath = './IMG_7948.JPG';  // **èƒŒæ™¯ç”»åƒ**
        const reflectionImagePath = './abstract_autumn_style_fixed.png';  // **çƒä½“ã®åå°„ç”»åƒ**

        // **èƒŒæ™¯ã¨åå°„ç”»åƒã‚’ãƒ­ãƒ¼ãƒ‰**
        textureLoader.load(backgroundImagePath, (backgroundTexture) => {
            backgroundTexture.colorSpace = THREE.SRGBColorSpace;

            // **èƒŒæ™¯ç”»åƒã‚’ãƒ¢ãƒã‚¯ãƒ­åŒ–**
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = backgroundTexture.image.width;
            canvas.height = backgroundTexture.image.height;
            ctx.drawImage(backgroundTexture.image, 0, 0);

            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            for (let i = 0; i < imageData.data.length; i += 4) {
                let gray = 0.299 * imageData.data[i] + 0.587 * imageData.data[i + 1] + 0.114 * imageData.data[i + 2];
                imageData.data[i] = gray;
                imageData.data[i + 1] = gray;
                imageData.data[i + 2] = gray;
            }
            ctx.putImageData(imageData, 0, 0);
            const grayscaleTexture = new THREE.CanvasTexture(canvas);

            // **èƒŒæ™¯ã‚’ãƒ¢ãƒã‚¯ãƒ­ã«è¨­å®š**
            scene.background = grayscaleTexture;

            // **çƒä½“ã®åå°„ç”¨ç”»åƒã‚’ãƒ­ãƒ¼ãƒ‰**
            textureLoader.load(reflectionImagePath, (reflectionTexture) => {
                reflectionTexture.colorSpace = THREE.SRGBColorSpace;

                // **æ³•ç·šãƒãƒƒãƒ—ï¼ˆçƒä½“ã®æ›²é¢ã®å½±éŸ¿ã‚’å†ç¾ã™ã‚‹ãŸã‚ï¼‰**
                const normalMap = textureLoader.load('https://threejs.org/examples/textures/waternormals.jpg');
                normalMap.wrapS = normalMap.wrapT = THREE.RepeatWrapping;

                // **ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒãƒ†ãƒªã‚¢ãƒ«ã‚’ä½œæˆ**
                const refractiveShader = new THREE.ShaderMaterial({
                    uniforms: {
                        reflectionTexture: { value: reflectionTexture }, // **çƒä½“ã®åå°„ç”»åƒ**
                        grayscaleTexture: { value: grayscaleTexture },  // **ãƒ¢ãƒã‚¯ãƒ­èƒŒæ™¯**
                        normalMap: { value: normalMap },
                        refractionStrength: { value: 0.03 }, // **å±ˆæŠ˜ã®å¼·ã•**
                        brightness: { value: 1.5 }, // **æ˜ã‚‹ã•è£œæ­£**
                        uCameraPosition: { value: camera.position } // **ã‚«ãƒ¡ãƒ©ã®ä½ç½®**
                    },
                    vertexShader: `
                        varying vec3 vNormal;
                        varying vec3 vViewPosition;
                        varying vec2 vUv;
                        
                        void main() {
                            vNormal = normalize(normalMatrix * normal);
                            vViewPosition = (modelViewMatrix * vec4(position, 1.0)).xyz;
                            vUv = uv;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform sampler2D reflectionTexture; // **çƒä½“ã®åå°„ç”¨ç”»åƒ**
                        uniform sampler2D grayscaleTexture;  // **èƒŒæ™¯ç”»åƒï¼ˆãƒ¢ãƒã‚¯ãƒ­ï¼‰**
                        uniform sampler2D normalMap;
                        uniform float refractionStrength;
                        uniform float brightness;
                        uniform vec3 uCameraPosition;
                        varying vec3 vNormal;
                        varying vec3 vViewPosition;
                        varying vec2 vUv;

                        void main() {
                            // **æ³•ç·šãƒãƒƒãƒ—ã‚’é©ç”¨**
                            vec3 normalColor = texture2D(normalMap, vUv * 2.0).rgb * 2.0 - 1.0;
                            vec3 normal = normalize(vNormal + normalColor * 0.2);

                            // **è¦–ç‚¹æ–¹å‘ã¨æ³•ç·šã®è¨ˆç®—**
                            vec3 viewDir = normalize(uCameraPosition - vViewPosition);
                            vec3 refractDir = refract(viewDir, normal, refractionStrength);

                            // **åå°„ç”¨ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’ã‚«ãƒ©ãƒ¼ã§å–å¾—**
                            vec2 refractedUV = vUv + refractDir.xy * 0.1;
                            vec4 reflectionColor = texture2D(reflectionTexture, refractedUV);

                            // **æ˜ã‚‹ã•è£œæ­£**
                            reflectionColor.rgb *= brightness;

                            // **æœ€çµ‚ã‚«ãƒ©ãƒ¼ã‚’é©ç”¨**
                            gl_FragColor = vec4(reflectionColor.rgb, 1.0);
                        }
                    `,
                    transparent: true
                });

                // **çƒä½“ã‚’ä½œæˆ**
                const sphereGeometry = new THREE.SphereGeometry(1, 128, 128);
                const sphere = new THREE.Mesh(sphereGeometry, refractiveShader);
                scene.add(sphere);

                // **ç…§æ˜ã‚’è¿½åŠ ï¼ˆç’°å¢ƒå…‰ï¼‰**
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
                scene.add(ambientLight);

                const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
                directionalLight.position.set(5, 5, 5);
                scene.add(directionalLight);

                // **å›è»¢é€Ÿåº¦ã‚’è¨­å®š**
                let rotationSpeedX = 0.005;
                let rotationSpeedY = 0.007;

                // **ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ«ãƒ¼ãƒ—**
                function animate() {
                    requestAnimationFrame(animate);

                    // **çƒä½“ã‚’å›è»¢**
                    sphere.rotation.x += rotationSpeedX;
                    sphere.rotation.y += rotationSpeedY;

                    // **ã‚«ãƒ¡ãƒ©ä½ç½®ã‚’çƒã®å›è»¢ã«å¿œã˜ã¦æ›´æ–°**
                    refractiveShader.uniforms.uCameraPosition.value.copy(camera.position);

                    renderer.render(scene, camera);
                }

                animate();
            });
        });

    </script>
</body>
</html>
-->


<!--ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ç«‹æ–¹ä½“ã€€ã‚¤ãƒ³ãƒ—ãƒƒãƒˆç”»åƒ2ã¤
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Reflective Cube with Separate Background & Reflection</title>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@latest/build/three.module.min.js"
            }
        }
    </script>
</head>
<body>
    <script type="module">
        import * as THREE from 'three';

        // **ã‚·ãƒ¼ãƒ³ã€ã‚«ãƒ¡ãƒ©ã€ãƒ¬ãƒ³ãƒ€ãƒ©ãƒ¼ã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—**
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 0, 5);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const textureLoader = new THREE.TextureLoader();

        // **ç”»åƒãƒ•ã‚¡ã‚¤ãƒ«ã‚’æŒ‡å®š**
        const backgroundImagePath = './IMG_7948.JPG';  // **èƒŒæ™¯ç”»åƒ**
        const reflectionImagePath = './abstract_water_style.png';  // **ç«‹æ–¹ä½“ã®åå°„ç”»åƒ**

        // **èƒŒæ™¯ã¨åå°„ç”»åƒã‚’ãƒ­ãƒ¼ãƒ‰**
        textureLoader.load(backgroundImagePath, (backgroundTexture) => {
            backgroundTexture.colorSpace = THREE.SRGBColorSpace;

            // **èƒŒæ™¯ç”»åƒã‚’ãƒ¢ãƒã‚¯ãƒ­åŒ–**
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = backgroundTexture.image.width;
            canvas.height = backgroundTexture.image.height;
            ctx.drawImage(backgroundTexture.image, 0, 0);

            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            for (let i = 0; i < imageData.data.length; i += 4) {
                let gray = 0.299 * imageData.data[i] + 0.587 * imageData.data[i + 1] + 0.114 * imageData.data[i + 2];
                imageData.data[i] = gray;
                imageData.data[i + 1] = gray;
                imageData.data[i + 2] = gray;
            }
            ctx.putImageData(imageData, 0, 0);
            const grayscaleTexture = new THREE.CanvasTexture(canvas);

            // **èƒŒæ™¯ã‚’ãƒ¢ãƒã‚¯ãƒ­ã«è¨­å®š**
            scene.background = grayscaleTexture;

            // **ç«‹æ–¹ä½“ã®åå°„ç”¨ç”»åƒã‚’ãƒ­ãƒ¼ãƒ‰**
            textureLoader.load(reflectionImagePath, (reflectionTexture) => {
                reflectionTexture.colorSpace = THREE.SRGBColorSpace;

                // **æ³•ç·šãƒãƒƒãƒ—ï¼ˆç«‹æ–¹ä½“ã®ã‚¨ãƒƒã‚¸ã®å½±éŸ¿ã‚’å†ç¾ï¼‰**
                const normalMap = textureLoader.load('https://threejs.org/examples/textures/waternormals.jpg');
                normalMap.wrapS = normalMap.wrapT = THREE.RepeatWrapping;

                // **ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒãƒ†ãƒªã‚¢ãƒ«ã‚’ä½œæˆ**
                const refractiveShader = new THREE.ShaderMaterial({
                    uniforms: {
                        reflectionTexture: { value: reflectionTexture }, // **ç«‹æ–¹ä½“ã®åå°„ç”»åƒ**
                        grayscaleTexture: { value: grayscaleTexture },  // **ãƒ¢ãƒã‚¯ãƒ­èƒŒæ™¯**
                        normalMap: { value: normalMap },
                        refractionStrength: { value: 0.05 }, // **å±ˆæŠ˜ã®å¼·ã•ï¼ˆç«‹æ–¹ä½“ã¯ã‚¨ãƒƒã‚¸ãŒã‚ã‚‹ãŸã‚å¢—åŠ ï¼‰**
                        brightness: { value: 1.5 }, // **æ˜ã‚‹ã•è£œæ­£**
                        uCameraPosition: { value: camera.position } // **ã‚«ãƒ¡ãƒ©ã®ä½ç½®**
                    },
                    vertexShader: `
                        varying vec3 vNormal;
                        varying vec3 vViewPosition;
                        varying vec2 vUv;
                        
                        void main() {
                            vNormal = normalize(normalMatrix * normal);
                            vViewPosition = (modelViewMatrix * vec4(position, 1.0)).xyz;
                            vUv = uv;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform sampler2D reflectionTexture; // **ç«‹æ–¹ä½“ã®åå°„ç”¨ç”»åƒ**
                        uniform sampler2D grayscaleTexture;  // **èƒŒæ™¯ç”»åƒï¼ˆãƒ¢ãƒã‚¯ãƒ­ï¼‰**
                        uniform sampler2D normalMap;
                        uniform float refractionStrength;
                        uniform float brightness;
                        uniform vec3 uCameraPosition;
                        varying vec3 vNormal;
                        varying vec3 vViewPosition;
                        varying vec2 vUv;

                        void main() {
                            // **æ³•ç·šãƒãƒƒãƒ—ã‚’é©ç”¨**
                            vec3 normalColor = texture2D(normalMap, vUv * 2.0).rgb * 2.0 - 1.0;
                            vec3 normal = normalize(vNormal + normalColor * 0.3);

                            // **è¦–ç‚¹æ–¹å‘ã¨æ³•ç·šã®è¨ˆç®—**
                            vec3 viewDir = normalize(uCameraPosition - vViewPosition);
                            vec3 refractDir = refract(viewDir, normal, refractionStrength);

                            // **åå°„ç”¨ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’ã‚«ãƒ©ãƒ¼ã§å–å¾—**
                            vec2 refractedUV = vUv + refractDir.xy * 0.15;
                            vec4 reflectionColor = texture2D(reflectionTexture, refractedUV);

                            // **æ˜ã‚‹ã•è£œæ­£**
                            reflectionColor.rgb *= brightness;

                            // **æœ€çµ‚ã‚«ãƒ©ãƒ¼ã‚’é©ç”¨**
                            gl_FragColor = vec4(reflectionColor.rgb, 1.0);
                        }
                    `,
                    transparent: true
                });

                // **ç«‹æ–¹ä½“ã‚’ä½œæˆ**
                const cubeGeometry = new THREE.BoxGeometry(1.5, 1.5, 1.5);
                const cube = new THREE.Mesh(cubeGeometry, refractiveShader);
                scene.add(cube);

                // **ç…§æ˜ã‚’è¿½åŠ ï¼ˆç’°å¢ƒå…‰ï¼‰**
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
                scene.add(ambientLight);

                const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
                directionalLight.position.set(5, 5, 5);
                scene.add(directionalLight);

                // **å›è»¢é€Ÿåº¦ã‚’è¨­å®š**
                let rotationSpeedX = 0.005;
                let rotationSpeedY = 0.007;

                // **ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ«ãƒ¼ãƒ—**
                function animate() {
                    requestAnimationFrame(animate);

                    // **ç«‹æ–¹ä½“ã‚’å›è»¢**
                    cube.rotation.x += rotationSpeedX;
                    cube.rotation.y += rotationSpeedY;

                    // **ã‚«ãƒ¡ãƒ©ä½ç½®ã‚’ç«‹æ–¹ä½“ã®å›è»¢ã«å¿œã˜ã¦æ›´æ–°**
                    refractiveShader.uniforms.uCameraPosition.value.copy(camera.position);

                    renderer.render(scene, camera);
                }

                animate();
            });
        });

    </script>
</body>
</html>
-->

<!--ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼4é¢ä½“ TetrahedronGeometryã§ç´°åˆ†åŒ–ã€€ã‚¤ãƒ³ãƒ—ãƒƒãƒˆç”»åƒ2ã¤
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rounded Tetrahedron with Reflection</title>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@latest/build/three.module.min.js",
                "three/examples/jsm/": "https://cdn.jsdelivr.net/npm/three@latest/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <script type="module">
        import * as THREE from 'three';

        // **ã‚·ãƒ¼ãƒ³ã€ã‚«ãƒ¡ãƒ©ã€ãƒ¬ãƒ³ãƒ€ãƒ©ãƒ¼ã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—**
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 0, 5);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const textureLoader = new THREE.TextureLoader();

        // **ç”»åƒãƒ•ã‚¡ã‚¤ãƒ«ã‚’æŒ‡å®š**
        const backgroundImagePath = './IMG_7948.JPG';  // **èƒŒæ™¯ç”»åƒ**
        const reflectionImagePath = './abstract_image1.png';  // **åå°„ç”»åƒ**

        // **èƒŒæ™¯ã¨åå°„ç”»åƒã‚’ãƒ­ãƒ¼ãƒ‰**
        textureLoader.load(backgroundImagePath, (backgroundTexture) => {
            backgroundTexture.colorSpace = THREE.SRGBColorSpace;

            // **èƒŒæ™¯ç”»åƒã‚’ãƒ¢ãƒã‚¯ãƒ­åŒ–**
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = backgroundTexture.image.width;
            canvas.height = backgroundTexture.image.height;
            ctx.drawImage(backgroundTexture.image, 0, 0);

            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            for (let i = 0; i < imageData.data.length; i += 4) {
                let gray = 0.299 * imageData.data[i] + 0.587 * imageData.data[i + 1] + 0.114 * imageData.data[i + 2];
                imageData.data[i] = gray;
                imageData.data[i + 1] = gray;
                imageData.data[i + 2] = gray;
            }
            ctx.putImageData(imageData, 0, 0);
            const grayscaleTexture = new THREE.CanvasTexture(canvas);

            // **èƒŒæ™¯ã‚’ãƒ¢ãƒã‚¯ãƒ­ã«è¨­å®š**
            scene.background = grayscaleTexture;

            // **å››é¢ä½“ã®åå°„ç”¨ç”»åƒã‚’ãƒ­ãƒ¼ãƒ‰**
            textureLoader.load(reflectionImagePath, (reflectionTexture) => {
                reflectionTexture.colorSpace = THREE.SRGBColorSpace;

                // **æ³•ç·šãƒãƒƒãƒ—ï¼ˆã‚¨ãƒƒã‚¸ã®ä¸¸ã¿ã‚’é©ç”¨ï¼‰**
                const normalMap = textureLoader.load('https://threejs.org/examples/textures/waternormals.jpg');
                normalMap.wrapS = normalMap.wrapT = THREE.RepeatWrapping;

                // **ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒãƒ†ãƒªã‚¢ãƒ«ã‚’ä½œæˆ**
                const refractiveShader = new THREE.ShaderMaterial({
                    uniforms: {
                        reflectionTexture: { value: reflectionTexture }, // **å››é¢ä½“ã®åå°„ç”»åƒ**
                        grayscaleTexture: { value: grayscaleTexture },  // **ãƒ¢ãƒã‚¯ãƒ­èƒŒæ™¯**
                        normalMap: { value: normalMap },
                        refractionStrength: { value: 0.07 }, // **å±ˆæŠ˜ã®å¼·ã•ï¼ˆä¸¸ã¿ã®å½±éŸ¿ã‚’å¼·èª¿ï¼‰**
                        brightness: { value: 1.6 }, // **æ˜ã‚‹ã•è£œæ­£**
                        uCameraPosition: { value: camera.position } // **ã‚«ãƒ¡ãƒ©ã®ä½ç½®**
                    },
                    vertexShader: `
                        varying vec3 vNormal;
                        varying vec3 vViewPosition;
                        varying vec2 vUv;
                        
                        void main() {
                            vNormal = normalize(normalMatrix * normal);
                            vViewPosition = (modelViewMatrix * vec4(position, 1.0)).xyz;
                            vUv = uv;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform sampler2D reflectionTexture; // **å››é¢ä½“ã®åå°„ç”¨ç”»åƒ**
                        uniform sampler2D grayscaleTexture;  // **èƒŒæ™¯ç”»åƒï¼ˆãƒ¢ãƒã‚¯ãƒ­ï¼‰**
                        uniform sampler2D normalMap;
                        uniform float refractionStrength;
                        uniform float brightness;
                        uniform vec3 uCameraPosition;
                        varying vec3 vNormal;
                        varying vec3 vViewPosition;
                        varying vec2 vUv;

                        void main() {
                            // **æ³•ç·šãƒãƒƒãƒ—ã‚’é©ç”¨**
                            vec3 normalColor = texture2D(normalMap, vUv * 2.0).rgb * 2.0 - 1.0;
                            vec3 normal = normalize(vNormal + normalColor * 0.3);

                            // **è¦–ç‚¹æ–¹å‘ã¨æ³•ç·šã®è¨ˆç®—**
                            vec3 viewDir = normalize(uCameraPosition - vViewPosition);
                            vec3 refractDir = refract(viewDir, normal, refractionStrength);

                            // **åå°„ç”¨ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’ã‚«ãƒ©ãƒ¼ã§å–å¾—**
                            vec2 refractedUV = vUv + refractDir.xy * 0.2;
                            vec4 reflectionColor = texture2D(reflectionTexture, refractedUV);

                            // **æ˜ã‚‹ã•è£œæ­£**
                            reflectionColor.rgb *= brightness;

                            // **æœ€çµ‚ã‚«ãƒ©ãƒ¼ã‚’é©ç”¨**
                            gl_FragColor = vec4(reflectionColor.rgb, 1.0);
                        }
                    `,
                    transparent: true
                });

                // **å››é¢ä½“ã‚’ä½œæˆã—ã€ä¸¸ã¿ã‚’æŒãŸã›ã‚‹**
                let tetrahedronGeometry = new THREE.TetrahedronGeometry(1.5, 2); // ç´°åˆ†åŒ–ãƒ¬ãƒ™ãƒ« 2 ã§ä¸¸ã¿ã‚’æŒãŸã›ã‚‹
                tetrahedronGeometry.computeVertexNormals(); // é ‚ç‚¹æ³•ç·šã‚’å†è¨ˆç®—

                const tetrahedron = new THREE.Mesh(tetrahedronGeometry, refractiveShader);
                scene.add(tetrahedron);

                // **ç…§æ˜ã‚’è¿½åŠ ï¼ˆç’°å¢ƒå…‰ï¼‰**
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
                scene.add(ambientLight);

                const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
                directionalLight.position.set(5, 5, 5);
                scene.add(directionalLight);

                // **å›è»¢é€Ÿåº¦ã‚’è¨­å®š**
                let rotationSpeedX = 0.006;
                let rotationSpeedY = 0.009;

                // **ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ«ãƒ¼ãƒ—**
                function animate() {
                    requestAnimationFrame(animate);

                    // **å››é¢ä½“ã‚’å›è»¢**
                    tetrahedron.rotation.x += rotationSpeedX;
                    tetrahedron.rotation.y += rotationSpeedY;

                    // **ã‚«ãƒ¡ãƒ©ä½ç½®ã‚’å››é¢ä½“ã®å›è»¢ã«å¿œã˜ã¦æ›´æ–°**
                    refractiveShader.uniforms.uCameraPosition.value.copy(camera.position);

                    renderer.render(scene, camera);
                }

                animate();
            });
        });

    </script>
</body>
</html>
-->

<!--ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼8é¢ä½“ TetrahedronGeometryã§ç´°åˆ†åŒ–ã€€ã‚¤ãƒ³ãƒ—ãƒƒãƒˆç”»åƒ2ã¤
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Reflective Octahedron with Separate Background & Reflection</title>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@latest/build/three.module.min.js"
            }
        }
    </script>
</head>
<body>
    <script type="module">
        import * as THREE from 'three';

        // **ã‚·ãƒ¼ãƒ³ã€ã‚«ãƒ¡ãƒ©ã€ãƒ¬ãƒ³ãƒ€ãƒ©ãƒ¼ã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—**
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 0, 5);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const textureLoader = new THREE.TextureLoader();

        // **ç”»åƒãƒ•ã‚¡ã‚¤ãƒ«ã‚’æŒ‡å®š**
        const backgroundImagePath = './IMG_7948.JPG';  // **èƒŒæ™¯ç”»åƒ**
        const reflectionImagePath = './abstract_image1.png';  // **åå°„ç”»åƒ**

        // **èƒŒæ™¯ã¨åå°„ç”»åƒã‚’ãƒ­ãƒ¼ãƒ‰**
        textureLoader.load(backgroundImagePath, (backgroundTexture) => {
            backgroundTexture.colorSpace = THREE.SRGBColorSpace;

            // **èƒŒæ™¯ç”»åƒã‚’ãƒ¢ãƒã‚¯ãƒ­åŒ–**
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = backgroundTexture.image.width;
            canvas.height = backgroundTexture.image.height;
            ctx.drawImage(backgroundTexture.image, 0, 0);

            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            for (let i = 0; i < imageData.data.length; i += 4) {
                let gray = 0.299 * imageData.data[i] + 0.587 * imageData.data[i + 1] + 0.114 * imageData.data[i + 2];
                imageData.data[i] = gray;
                imageData.data[i + 1] = gray;
                imageData.data[i + 2] = gray;
            }
            ctx.putImageData(imageData, 0, 0);
            const grayscaleTexture = new THREE.CanvasTexture(canvas);

            // **èƒŒæ™¯ã‚’ãƒ¢ãƒã‚¯ãƒ­ã«è¨­å®š**
            scene.background = grayscaleTexture;

            // **å…«é¢ä½“ã®åå°„ç”¨ç”»åƒã‚’ãƒ­ãƒ¼ãƒ‰**
            textureLoader.load(reflectionImagePath, (reflectionTexture) => {
                reflectionTexture.colorSpace = THREE.SRGBColorSpace;

                // **æ³•ç·šãƒãƒƒãƒ—ï¼ˆå…«é¢ä½“ã®é¢ã®å½±éŸ¿ã‚’å†ç¾ï¼‰**
                const normalMap = textureLoader.load('https://threejs.org/examples/textures/waternormals.jpg');
                normalMap.wrapS = normalMap.wrapT = THREE.RepeatWrapping;

                // **ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒãƒ†ãƒªã‚¢ãƒ«ã‚’ä½œæˆ**
                const refractiveShader = new THREE.ShaderMaterial({
                    uniforms: {
                        reflectionTexture: { value: reflectionTexture }, // **å…«é¢ä½“ã®åå°„ç”»åƒ**
                        grayscaleTexture: { value: grayscaleTexture },  // **ãƒ¢ãƒã‚¯ãƒ­èƒŒæ™¯**
                        normalMap: { value: normalMap },
                        refractionStrength: { value: 0.06 }, // **å±ˆæŠ˜ã®å¼·ã•**
                        brightness: { value: 1.6 }, // **æ˜ã‚‹ã•è£œæ­£**
                        uCameraPosition: { value: camera.position } // **ã‚«ãƒ¡ãƒ©ã®ä½ç½®**
                    },
                    vertexShader: `
                        varying vec3 vNormal;
                        varying vec3 vViewPosition;
                        varying vec2 vUv;
                        
                        void main() {
                            vNormal = normalize(normalMatrix * normal);
                            vViewPosition = (modelViewMatrix * vec4(position, 1.0)).xyz;
                            vUv = uv;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform sampler2D reflectionTexture; // **å…«é¢ä½“ã®åå°„ç”¨ç”»åƒ**
                        uniform sampler2D grayscaleTexture;  // **èƒŒæ™¯ç”»åƒï¼ˆãƒ¢ãƒã‚¯ãƒ­ï¼‰**
                        uniform sampler2D normalMap;
                        uniform float refractionStrength;
                        uniform float brightness;
                        uniform vec3 uCameraPosition;
                        varying vec3 vNormal;
                        varying vec3 vViewPosition;
                        varying vec2 vUv;

                        void main() {
                            // **æ³•ç·šãƒãƒƒãƒ—ã‚’é©ç”¨**
                            vec3 normalColor = texture2D(normalMap, vUv * 2.0).rgb * 2.0 - 1.0;
                            vec3 normal = normalize(vNormal + normalColor * 0.3);

                            // **è¦–ç‚¹æ–¹å‘ã¨æ³•ç·šã®è¨ˆç®—**
                            vec3 viewDir = normalize(uCameraPosition - vViewPosition);
                            vec3 refractDir = refract(viewDir, normal, refractionStrength);

                            // **åå°„ç”¨ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’ã‚«ãƒ©ãƒ¼ã§å–å¾—**
                            vec2 refractedUV = vUv + refractDir.xy * 0.2;
                            vec4 reflectionColor = texture2D(reflectionTexture, refractedUV);

                            // **æ˜ã‚‹ã•è£œæ­£**
                            reflectionColor.rgb *= brightness;

                            // **æœ€çµ‚ã‚«ãƒ©ãƒ¼ã‚’é©ç”¨**
                            gl_FragColor = vec4(reflectionColor.rgb, 1.0);
                        }
                    `,
                    transparent: true
                });

                // **å…«é¢ä½“ã‚’ä½œæˆ**
                const octahedronGeometry = new THREE.OctahedronGeometry(1.5, 2); // `0` ã¯åˆ†å‰²æ•°
                const octahedron = new THREE.Mesh(octahedronGeometry, refractiveShader);
                scene.add(octahedron);

                // **ç…§æ˜ã‚’è¿½åŠ ï¼ˆç’°å¢ƒå…‰ï¼‰**
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
                scene.add(ambientLight);

                const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
                directionalLight.position.set(5, 5, 5);
                scene.add(directionalLight);

                // **å›è»¢é€Ÿåº¦ã‚’è¨­å®š**
                let rotationSpeedX = 0.005;
                let rotationSpeedY = 0.007;

                // **ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ«ãƒ¼ãƒ—**
                function animate() {
                    requestAnimationFrame(animate);

                    // **å…«é¢ä½“ã‚’å›è»¢**
                    octahedron.rotation.x += rotationSpeedX;
                    octahedron.rotation.y += rotationSpeedY;

                    // **ã‚«ãƒ¡ãƒ©ä½ç½®ã‚’å…«é¢ä½“ã®å›è»¢ã«å¿œã˜ã¦æ›´æ–°**
                    refractiveShader.uniforms.uCameraPosition.value.copy(camera.position);

                    renderer.render(scene, camera);
                }

                animate();
            });
        });

    </script>
</body>
</html>
-->

<!--ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼12é¢ä½“ TetrahedronGeometryã§ç´°åˆ†åŒ–ã€€ã‚¤ãƒ³ãƒ—ãƒƒãƒˆç”»åƒ2ã¤

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Reflective Dodecahedron with Separate Background & Reflection</title>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@latest/build/three.module.min.js"
            }
        }
    </script>
</head>
<body>
    <script type="module">
        import * as THREE from 'three';

        // **ã‚·ãƒ¼ãƒ³ã€ã‚«ãƒ¡ãƒ©ã€ãƒ¬ãƒ³ãƒ€ãƒ©ãƒ¼ã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—**
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 0, 5);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const textureLoader = new THREE.TextureLoader();

        // **ç”»åƒãƒ•ã‚¡ã‚¤ãƒ«ã‚’æŒ‡å®š**
        const backgroundImagePath = './IMG_7940.JPG';  // **èƒŒæ™¯ç”»åƒ**
        const reflectionImagePath = './abstract_image1.png';  // **åäºŒé¢ä½“ã®åå°„ç”»åƒ**

        // **èƒŒæ™¯ã¨åå°„ç”»åƒã‚’ãƒ­ãƒ¼ãƒ‰**
        textureLoader.load(backgroundImagePath, (backgroundTexture) => {
            backgroundTexture.colorSpace = THREE.SRGBColorSpace;

            // **èƒŒæ™¯ç”»åƒã‚’ãƒ¢ãƒã‚¯ãƒ­åŒ–**
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = backgroundTexture.image.width;
            canvas.height = backgroundTexture.image.height;
            ctx.drawImage(backgroundTexture.image, 0, 0);

            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            for (let i = 0; i < imageData.data.length; i += 4) {
                let gray = 0.299 * imageData.data[i] + 0.587 * imageData.data[i + 1] + 0.114 * imageData.data[i + 2];
                imageData.data[i] = gray;
                imageData.data[i + 1] = gray;
                imageData.data[i + 2] = gray;
            }
            ctx.putImageData(imageData, 0, 0);
            const grayscaleTexture = new THREE.CanvasTexture(canvas);

            // **èƒŒæ™¯ã‚’ãƒ¢ãƒã‚¯ãƒ­ã«è¨­å®š**
            scene.background = grayscaleTexture;

            // **åäºŒé¢ä½“ã®åå°„ç”¨ç”»åƒã‚’ãƒ­ãƒ¼ãƒ‰**
            textureLoader.load(reflectionImagePath, (reflectionTexture) => {
                reflectionTexture.colorSpace = THREE.SRGBColorSpace;

                // **æ³•ç·šãƒãƒƒãƒ—ï¼ˆåäºŒé¢ä½“ã®é¢ã®å½±éŸ¿ã‚’å†ç¾ï¼‰**
                const normalMap = textureLoader.load('https://threejs.org/examples/textures/waternormals.jpg');
                normalMap.wrapS = normalMap.wrapT = THREE.RepeatWrapping;

                // **ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒãƒ†ãƒªã‚¢ãƒ«ã‚’ä½œæˆ**
                const refractiveShader = new THREE.ShaderMaterial({
                    uniforms: {
                        reflectionTexture: { value: reflectionTexture }, // **åäºŒé¢ä½“ã®åå°„ç”»åƒ**
                        grayscaleTexture: { value: grayscaleTexture },  // **ãƒ¢ãƒã‚¯ãƒ­èƒŒæ™¯**
                        normalMap: { value: normalMap },
                        refractionStrength: { value: 0.05 }, // **å±ˆæŠ˜ã®å¼·ã•**
                        brightness: { value: 1.6 }, // **æ˜ã‚‹ã•è£œæ­£**
                        uCameraPosition: { value: camera.position } // **ã‚«ãƒ¡ãƒ©ã®ä½ç½®**
                    },
                    vertexShader: `
                        varying vec3 vNormal;
                        varying vec3 vViewPosition;
                        varying vec2 vUv;
                        
                        void main() {
                            vNormal = normalize(normalMatrix * normal);
                            vViewPosition = (modelViewMatrix * vec4(position, 1.0)).xyz;
                            vUv = uv;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform sampler2D reflectionTexture; // **åäºŒé¢ä½“ã®åå°„ç”¨ç”»åƒ**
                        uniform sampler2D grayscaleTexture;  // **èƒŒæ™¯ç”»åƒï¼ˆãƒ¢ãƒã‚¯ãƒ­ï¼‰**
                        uniform sampler2D normalMap;
                        uniform float refractionStrength;
                        uniform float brightness;
                        uniform vec3 uCameraPosition;
                        varying vec3 vNormal;
                        varying vec3 vViewPosition;
                        varying vec2 vUv;

                        void main() {
                            // **æ³•ç·šãƒãƒƒãƒ—ã‚’é©ç”¨**
                            vec3 normalColor = texture2D(normalMap, vUv * 2.0).rgb * 2.0 - 1.0;
                            vec3 normal = normalize(vNormal + normalColor * 0.3);

                            // **è¦–ç‚¹æ–¹å‘ã¨æ³•ç·šã®è¨ˆç®—**
                            vec3 viewDir = normalize(uCameraPosition - vViewPosition);
                            vec3 refractDir = refract(viewDir, normal, refractionStrength);

                            // **åå°„ç”¨ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’ã‚«ãƒ©ãƒ¼ã§å–å¾—**
                            vec2 refractedUV = vUv + refractDir.xy * 0.2;
                            vec4 reflectionColor = texture2D(reflectionTexture, refractedUV);

                            // **æ˜ã‚‹ã•è£œæ­£**
                            reflectionColor.rgb *= brightness;

                            // **æœ€çµ‚ã‚«ãƒ©ãƒ¼ã‚’é©ç”¨**
                            gl_FragColor = vec4(reflectionColor.rgb, 1.0);
                        }
                    `,
                    transparent: true
                });

                // **åäºŒé¢ä½“ã‚’ä½œæˆ**
                const dodecahedronGeometry = new THREE.DodecahedronGeometry(1.5, 0); // `0` ã¯åˆ†å‰²æ•°
                const dodecahedron = new THREE.Mesh(dodecahedronGeometry, refractiveShader);
                scene.add(dodecahedron);

                // **ç…§æ˜ã‚’è¿½åŠ ï¼ˆç’°å¢ƒå…‰ï¼‰**
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
                scene.add(ambientLight);

                const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
                directionalLight.position.set(5, 5, 5);
                scene.add(directionalLight);

                // **å›è»¢é€Ÿåº¦ã‚’è¨­å®š**
                let rotationSpeedX = 0.005;
                let rotationSpeedY = 0.007;

                // **ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ«ãƒ¼ãƒ—**
                function animate() {
                    requestAnimationFrame(animate);

                    // **åäºŒé¢ä½“ã‚’å›è»¢**
                    dodecahedron.rotation.x += rotationSpeedX;
                    dodecahedron.rotation.y += rotationSpeedY;

                    // **ã‚«ãƒ¡ãƒ©ä½ç½®ã‚’åäºŒé¢ä½“ã®å›è»¢ã«å¿œã˜ã¦æ›´æ–°**
                    refractiveShader.uniforms.uCameraPosition.value.copy(camera.position);

                    renderer.render(scene, camera);
                }

                animate();
            });
        });

    </script>
</body>
</html>
-->

<!--20é¢ä½“
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Reflective Icosahedron with Separate Background & Reflection</title>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@latest/build/three.module.min.js"
            }
        }
    </script>
</head>
<body>
    <script type="module">
        import * as THREE from 'three';

        // **ã‚·ãƒ¼ãƒ³ã€ã‚«ãƒ¡ãƒ©ã€ãƒ¬ãƒ³ãƒ€ãƒ©ãƒ¼ã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—**
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 0, 5);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const textureLoader = new THREE.TextureLoader();

        // **ç”»åƒãƒ•ã‚¡ã‚¤ãƒ«ã‚’æŒ‡å®š**
        const backgroundImagePath = './IMG_7940.JPG';  // **èƒŒæ™¯ç”»åƒ**
        const reflectionImagePath = './abstract_water_style.png';  // **äºŒåé¢ä½“ã®åå°„ç”»åƒ**

        // **èƒŒæ™¯ã¨åå°„ç”»åƒã‚’ãƒ­ãƒ¼ãƒ‰**
        textureLoader.load(backgroundImagePath, (backgroundTexture) => {
            backgroundTexture.colorSpace = THREE.SRGBColorSpace;

            // **èƒŒæ™¯ç”»åƒã‚’ãƒ¢ãƒã‚¯ãƒ­åŒ–**
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = backgroundTexture.image.width;
            canvas.height = backgroundTexture.image.height;
            ctx.drawImage(backgroundTexture.image, 0, 0);

            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            for (let i = 0; i < imageData.data.length; i += 4) {
                let gray = 0.299 * imageData.data[i] + 0.587 * imageData.data[i + 1] + 0.114 * imageData.data[i + 2];
                imageData.data[i] = gray;
                imageData.data[i + 1] = gray;
                imageData.data[i + 2] = gray;
            }
            ctx.putImageData(imageData, 0, 0);
            const grayscaleTexture = new THREE.CanvasTexture(canvas);

            // **èƒŒæ™¯ã‚’ãƒ¢ãƒã‚¯ãƒ­ã«è¨­å®š**
            scene.background = grayscaleTexture;

            // **äºŒåé¢ä½“ã®åå°„ç”¨ç”»åƒã‚’ãƒ­ãƒ¼ãƒ‰**
            textureLoader.load(reflectionImagePath, (reflectionTexture) => {
                reflectionTexture.colorSpace = THREE.SRGBColorSpace;

                // **æ³•ç·šãƒãƒƒãƒ—ï¼ˆé¢ã®å½±éŸ¿ã‚’å†ç¾ï¼‰**
                const normalMap = textureLoader.load('https://threejs.org/examples/textures/waternormals.jpg');
                normalMap.wrapS = normalMap.wrapT = THREE.RepeatWrapping;

                // **ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒãƒ†ãƒªã‚¢ãƒ«ã‚’ä½œæˆ**
                const refractiveShader = new THREE.ShaderMaterial({
                    uniforms: {
                        reflectionTexture: { value: reflectionTexture }, // **äºŒåé¢ä½“ã®åå°„ç”»åƒ**
                        grayscaleTexture: { value: grayscaleTexture },  // **ãƒ¢ãƒã‚¯ãƒ­èƒŒæ™¯**
                        normalMap: { value: normalMap },
                        refractionStrength: { value: 0.05 }, // **å±ˆæŠ˜ã®å¼·ã•**
                        brightness: { value: 1.6 }, // **æ˜ã‚‹ã•è£œæ­£**
                        uCameraPosition: { value: camera.position } // **ã‚«ãƒ¡ãƒ©ã®ä½ç½®**
                    },
                    vertexShader: `
                        varying vec3 vNormal;
                        varying vec3 vViewPosition;
                        varying vec2 vUv;
                        
                        void main() {
                            vNormal = normalize(normalMatrix * normal);
                            vViewPosition = (modelViewMatrix * vec4(position, 1.0)).xyz;
                            vUv = uv;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform sampler2D reflectionTexture; // **äºŒåé¢ä½“ã®åå°„ç”¨ç”»åƒ**
                        uniform sampler2D grayscaleTexture;  // **èƒŒæ™¯ç”»åƒï¼ˆãƒ¢ãƒã‚¯ãƒ­ï¼‰**
                        uniform sampler2D normalMap;
                        uniform float refractionStrength;
                        uniform float brightness;
                        uniform vec3 uCameraPosition;
                        varying vec3 vNormal;
                        varying vec3 vViewPosition;
                        varying vec2 vUv;

                        void main() {
                            // **æ³•ç·šãƒãƒƒãƒ—ã‚’é©ç”¨**
                            vec3 normalColor = texture2D(normalMap, vUv * 2.0).rgb * 2.0 - 1.0;
                            vec3 normal = normalize(vNormal + normalColor * 0.3);

                            // **è¦–ç‚¹æ–¹å‘ã¨æ³•ç·šã®è¨ˆç®—**
                            vec3 viewDir = normalize(uCameraPosition - vViewPosition);
                            vec3 refractDir = refract(viewDir, normal, refractionStrength);

                            // **åå°„ç”¨ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’ã‚«ãƒ©ãƒ¼ã§å–å¾—**
                            vec2 refractedUV = vUv + refractDir.xy * 0.2;
                            vec4 reflectionColor = texture2D(reflectionTexture, refractedUV);

                            // **æ˜ã‚‹ã•è£œæ­£**
                            reflectionColor.rgb *= brightness;

                            // **æœ€çµ‚ã‚«ãƒ©ãƒ¼ã‚’é©ç”¨**
                            gl_FragColor = vec4(reflectionColor.rgb, 1.0);
                        }
                    `,
                    transparent: true
                });

                // **äºŒåé¢ä½“ã‚’ä½œæˆ**
                const icosahedronGeometry = new THREE.IcosahedronGeometry(1.5, 1); // `0` ã¯åˆ†å‰²æ•°
                const icosahedron = new THREE.Mesh(icosahedronGeometry, refractiveShader);
                scene.add(icosahedron);

                // **ç…§æ˜ã‚’è¿½åŠ ï¼ˆç’°å¢ƒå…‰ï¼‰**
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
                scene.add(ambientLight);

                const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
                directionalLight.position.set(5, 5, 5);
                scene.add(directionalLight);

                // **å›è»¢é€Ÿåº¦ã‚’è¨­å®š**
                let rotationSpeedX = 0.005;
                let rotationSpeedY = 0.007;

                // **ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ«ãƒ¼ãƒ—**
                function animate() {
                    requestAnimationFrame(animate);

                    // **äºŒåé¢ä½“ã‚’å›è»¢**
                    icosahedron.rotation.x += rotationSpeedX;
                    icosahedron.rotation.y += rotationSpeedY;

                    // **ã‚«ãƒ¡ãƒ©ä½ç½®ã‚’äºŒåé¢ä½“ã®å›è»¢ã«å¿œã˜ã¦æ›´æ–°**
                    refractiveShader.uniforms.uCameraPosition.value.copy(camera.position);

                    renderer.render(scene, camera);
                }

                animate();
            });
        });

    </script>
</body>
</html>
-->

<!--å††æŸ±
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Reflective Cylinder with Separate Background & Reflection</title>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@latest/build/three.module.min.js"
            }
        }
    </script>
</head>
<body>
    <script type="module">
        import * as THREE from 'three';

        // **ã‚·ãƒ¼ãƒ³ã€ã‚«ãƒ¡ãƒ©ã€ãƒ¬ãƒ³ãƒ€ãƒ©ãƒ¼ã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—**
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 0, 5);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const textureLoader = new THREE.TextureLoader();

        // **ç”»åƒãƒ•ã‚¡ã‚¤ãƒ«ã‚’æŒ‡å®š**
        const backgroundImagePath = './IMG_7940.JPG';  // **èƒŒæ™¯ç”»åƒ**
        const reflectionImagePath = './abstract_image1.png';  // **å††æŸ±ã®åå°„ç”»åƒ**

        // **èƒŒæ™¯ã¨åå°„ç”»åƒã‚’ãƒ­ãƒ¼ãƒ‰**
        textureLoader.load(backgroundImagePath, (backgroundTexture) => {
            backgroundTexture.colorSpace = THREE.SRGBColorSpace;

            // **èƒŒæ™¯ç”»åƒã‚’ãƒ¢ãƒã‚¯ãƒ­åŒ–**
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = backgroundTexture.image.width;
            canvas.height = backgroundTexture.image.height;
            ctx.drawImage(backgroundTexture.image, 0, 0);

            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            for (let i = 0; i < imageData.data.length; i += 4) {
                let gray = 0.299 * imageData.data[i] + 0.587 * imageData.data[i + 1] + 0.114 * imageData.data[i + 2];
                imageData.data[i] = gray;
                imageData.data[i + 1] = gray;
                imageData.data[i + 2] = gray;
            }
            ctx.putImageData(imageData, 0, 0);
            const grayscaleTexture = new THREE.CanvasTexture(canvas);

            // **èƒŒæ™¯ã‚’ãƒ¢ãƒã‚¯ãƒ­ã«è¨­å®š**
            scene.background = grayscaleTexture;

            // **å††æŸ±ã®åå°„ç”¨ç”»åƒã‚’ãƒ­ãƒ¼ãƒ‰**
            textureLoader.load(reflectionImagePath, (reflectionTexture) => {
                reflectionTexture.colorSpace = THREE.SRGBColorSpace;

                // **æ³•ç·šãƒãƒƒãƒ—ï¼ˆå††æŸ±ã®è¡¨é¢ã®å½±éŸ¿ã‚’å†ç¾ï¼‰**
                const normalMap = textureLoader.load('https://threejs.org/examples/textures/waternormals.jpg');
                normalMap.wrapS = normalMap.wrapT = THREE.RepeatWrapping;

                // **ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒãƒ†ãƒªã‚¢ãƒ«ã‚’ä½œæˆ**
                const refractiveShader = new THREE.ShaderMaterial({
                    uniforms: {
                        reflectionTexture: { value: reflectionTexture }, // **å††æŸ±ã®åå°„ç”»åƒ**
                        grayscaleTexture: { value: grayscaleTexture },  // **ãƒ¢ãƒã‚¯ãƒ­èƒŒæ™¯**
                        normalMap: { value: normalMap },
                        refractionStrength: { value: 0.04 }, // **å±ˆæŠ˜ã®å¼·ã•**
                        brightness: { value: 1.6 }, // **æ˜ã‚‹ã•è£œæ­£**
                        uCameraPosition: { value: camera.position } // **ã‚«ãƒ¡ãƒ©ã®ä½ç½®**
                    },
                    vertexShader: `
                        varying vec3 vNormal;
                        varying vec3 vViewPosition;
                        varying vec2 vUv;
                        
                        void main() {
                            vNormal = normalize(normalMatrix * normal);
                            vViewPosition = (modelViewMatrix * vec4(position, 1.0)).xyz;
                            vUv = uv;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform sampler2D reflectionTexture; // **å††æŸ±ã®åå°„ç”¨ç”»åƒ**
                        uniform sampler2D grayscaleTexture;  // **èƒŒæ™¯ç”»åƒï¼ˆãƒ¢ãƒã‚¯ãƒ­ï¼‰**
                        uniform sampler2D normalMap;
                        uniform float refractionStrength;
                        uniform float brightness;
                        uniform vec3 uCameraPosition;
                        varying vec3 vNormal;
                        varying vec3 vViewPosition;
                        varying vec2 vUv;

                        void main() {
                            // **æ³•ç·šãƒãƒƒãƒ—ã‚’é©ç”¨**
                            vec3 normalColor = texture2D(normalMap, vUv * 2.0).rgb * 2.0 - 1.0;
                            vec3 normal = normalize(vNormal + normalColor * 0.3);

                            // **è¦–ç‚¹æ–¹å‘ã¨æ³•ç·šã®è¨ˆç®—**
                            vec3 viewDir = normalize(uCameraPosition - vViewPosition);
                            vec3 refractDir = refract(viewDir, normal, refractionStrength);

                            // **åå°„ç”¨ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’ã‚«ãƒ©ãƒ¼ã§å–å¾—**
                            vec2 refractedUV = vUv + refractDir.xy * 0.2;
                            vec4 reflectionColor = texture2D(reflectionTexture, refractedUV);

                            // **æ˜ã‚‹ã•è£œæ­£**
                            reflectionColor.rgb *= brightness;

                            // **æœ€çµ‚ã‚«ãƒ©ãƒ¼ã‚’é©ç”¨**
                            gl_FragColor = vec4(reflectionColor.rgb, 1.0);
                        }
                    `,
                    transparent: true
                });

                // **å††æŸ±ã‚’ä½œæˆ**
                const cylinderGeometry = new THREE.CylinderGeometry(1, 1, 2, 32); // `32` ã¯å††å‘¨ã®åˆ†å‰²æ•°ï¼ˆæ»‘ã‚‰ã‹ã•èª¿æ•´ï¼‰
                const cylinder = new THREE.Mesh(cylinderGeometry, refractiveShader);
                scene.add(cylinder);

                // **ç…§æ˜ã‚’è¿½åŠ ï¼ˆç’°å¢ƒå…‰ï¼‰**
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
                scene.add(ambientLight);

                const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
                directionalLight.position.set(5, 5, 5);
                scene.add(directionalLight);

                // **å›è»¢é€Ÿåº¦ã‚’è¨­å®š**
                let rotationSpeedX = 0.005;
                let rotationSpeedY = 0.007;

                // **ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ«ãƒ¼ãƒ—**
                function animate() {
                    requestAnimationFrame(animate);

                    // **å††æŸ±ã‚’å›è»¢**
                    cylinder.rotation.x += rotationSpeedX;
                    cylinder.rotation.y += rotationSpeedY;

                    // **ã‚«ãƒ¡ãƒ©ä½ç½®ã‚’å††æŸ±ã®å›è»¢ã«å¿œã˜ã¦æ›´æ–°**
                    refractiveShader.uniforms.uCameraPosition.value.copy(camera.position);

                    renderer.render(scene, camera);
                }

                animate();
            });
        });

    </script>
</body>
</html>
-->

<!--ãƒˆãƒ¼ãƒ©ã‚¹
// å½¢ã‚’æ»‘ã‚‰ã‹ã«ã—ãŸã„å ´åˆã¯ TorusGeometry(1.2, 0.4, 64, 128) ã«å¤‰æ›´å¯èƒ½
// ç´°é•·ã„ãƒˆãƒ¼ãƒ©ã‚¹ (TorusGeometry(1.5, 0.2, 64, 128))

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Reflective Torus with Separate Background & Reflection</title>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@latest/build/three.module.min.js"
            }
        }
    </script>
</head>
<body>
    <script type="module">
        import * as THREE from 'three';

        // **ã‚·ãƒ¼ãƒ³ã€ã‚«ãƒ¡ãƒ©ã€ãƒ¬ãƒ³ãƒ€ãƒ©ãƒ¼ã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—**
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 0, 5);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const textureLoader = new THREE.TextureLoader();

        // **ç”»åƒãƒ•ã‚¡ã‚¤ãƒ«ã‚’æŒ‡å®š**
        const backgroundImagePath = './IMG_7940.JPG';  // **èƒŒæ™¯ç”»åƒ**
        const reflectionImagePath = './abstract_image1.png';  // **ãƒˆãƒ¼ãƒ©ã‚¹ã®åå°„ç”»åƒ**

        // **èƒŒæ™¯ã¨åå°„ç”»åƒã‚’ãƒ­ãƒ¼ãƒ‰**
        textureLoader.load(backgroundImagePath, (backgroundTexture) => {
            backgroundTexture.colorSpace = THREE.SRGBColorSpace;

            // **èƒŒæ™¯ç”»åƒã‚’ãƒ¢ãƒã‚¯ãƒ­åŒ–**
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = backgroundTexture.image.width;
            canvas.height = backgroundTexture.image.height;
            ctx.drawImage(backgroundTexture.image, 0, 0);

            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            for (let i = 0; i < imageData.data.length; i += 4) {
                let gray = 0.299 * imageData.data[i] + 0.587 * imageData.data[i + 1] + 0.114 * imageData.data[i + 2];
                imageData.data[i] = gray;
                imageData.data[i + 1] = gray;
                imageData.data[i + 2] = gray;
            }
            ctx.putImageData(imageData, 0, 0);
            const grayscaleTexture = new THREE.CanvasTexture(canvas);

            // **èƒŒæ™¯ã‚’ãƒ¢ãƒã‚¯ãƒ­ã«è¨­å®š**
            scene.background = grayscaleTexture;

            // **ãƒˆãƒ¼ãƒ©ã‚¹ã®åå°„ç”¨ç”»åƒã‚’ãƒ­ãƒ¼ãƒ‰**
            textureLoader.load(reflectionImagePath, (reflectionTexture) => {
                reflectionTexture.colorSpace = THREE.SRGBColorSpace;

                // **æ³•ç·šãƒãƒƒãƒ—ï¼ˆè¡¨é¢ã®å½±éŸ¿ã‚’å†ç¾ï¼‰**
                const normalMap = textureLoader.load('https://threejs.org/examples/textures/waternormals.jpg');
                normalMap.wrapS = normalMap.wrapT = THREE.RepeatWrapping;

                // **ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒãƒ†ãƒªã‚¢ãƒ«ã‚’ä½œæˆ**
                const refractiveShader = new THREE.ShaderMaterial({
                    uniforms: {
                        reflectionTexture: { value: reflectionTexture }, // **ãƒˆãƒ¼ãƒ©ã‚¹ã®åå°„ç”»åƒ**
                        grayscaleTexture: { value: grayscaleTexture },  // **ãƒ¢ãƒã‚¯ãƒ­èƒŒæ™¯**
                        normalMap: { value: normalMap },
                        refractionStrength: { value: 0.03 }, // **å±ˆæŠ˜ã®å¼·ã•**
                        brightness: { value: 1.6 }, // **æ˜ã‚‹ã•è£œæ­£**
                        uCameraPosition: { value: camera.position } // **ã‚«ãƒ¡ãƒ©ã®ä½ç½®**
                    },
                    vertexShader: `
                        varying vec3 vNormal;
                        varying vec3 vViewPosition;
                        varying vec2 vUv;
                        
                        void main() {
                            vNormal = normalize(normalMatrix * normal);
                            vViewPosition = (modelViewMatrix * vec4(position, 1.0)).xyz;
                            vUv = uv;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform sampler2D reflectionTexture; // **ãƒˆãƒ¼ãƒ©ã‚¹ã®åå°„ç”¨ç”»åƒ**
                        uniform sampler2D grayscaleTexture;  // **èƒŒæ™¯ç”»åƒï¼ˆãƒ¢ãƒã‚¯ãƒ­ï¼‰**
                        uniform sampler2D normalMap;
                        uniform float refractionStrength;
                        uniform float brightness;
                        uniform vec3 uCameraPosition;
                        varying vec3 vNormal;
                        varying vec3 vViewPosition;
                        varying vec2 vUv;

                        void main() {
                            // **æ³•ç·šãƒãƒƒãƒ—ã‚’é©ç”¨**
                            vec3 normalColor = texture2D(normalMap, vUv * 2.0).rgb * 2.0 - 1.0;
                            vec3 normal = normalize(vNormal + normalColor * 0.3);

                            // **è¦–ç‚¹æ–¹å‘ã¨æ³•ç·šã®è¨ˆç®—**
                            vec3 viewDir = normalize(uCameraPosition - vViewPosition);
                            vec3 refractDir = refract(viewDir, normal, refractionStrength);

                            // **åå°„ç”¨ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’ã‚«ãƒ©ãƒ¼ã§å–å¾—**
                            vec2 refractedUV = vUv + refractDir.xy * 0.2;
                            vec4 reflectionColor = texture2D(reflectionTexture, refractedUV);

                            // **æ˜ã‚‹ã•è£œæ­£**
                            reflectionColor.rgb *= brightness;

                            // **æœ€çµ‚ã‚«ãƒ©ãƒ¼ã‚’é©ç”¨**
                            gl_FragColor = vec4(reflectionColor.rgb, 1.0);
                        }
                    `,
                    transparent: true
                });

                // **ãƒˆãƒ¼ãƒ©ã‚¹ã‚’ä½œæˆ**
                const torusGeometry = new THREE.TorusGeometry(1.2, 0.4, 32, 64); // `32` åˆ†å‰² & `64` ãƒãƒ¥ãƒ¼ãƒ–åˆ†å‰²
                const torus = new THREE.Mesh(torusGeometry, refractiveShader);
                scene.add(torus);

                // **ç…§æ˜ã‚’è¿½åŠ ï¼ˆç’°å¢ƒå…‰ï¼‰**
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
                scene.add(ambientLight);

                const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
                directionalLight.position.set(5, 5, 5);
                scene.add(directionalLight);

                // **å›è»¢é€Ÿåº¦ã‚’è¨­å®š**
                let rotationSpeedX = 0.005;
                let rotationSpeedY = 0.007;

                // **ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ«ãƒ¼ãƒ—**
                function animate() {
                    requestAnimationFrame(animate);

                    // **ãƒˆãƒ¼ãƒ©ã‚¹ã‚’å›è»¢**
                    torus.rotation.x += rotationSpeedX;
                    torus.rotation.y += rotationSpeedY;

                    // **ã‚«ãƒ¡ãƒ©ä½ç½®ã‚’ãƒˆãƒ¼ãƒ©ã‚¹ã®å›è»¢ã«å¿œã˜ã¦æ›´æ–°**
                    refractiveShader.uniforms.uCameraPosition.value.copy(camera.position);

                    renderer.render(scene, camera);
                }

                animate();
            });
        });

    </script>
</body>
</html>
-->

<!--ãƒˆãƒ¼ãƒ©ã‚¹ãƒãƒƒãƒˆ
TorusKnotGeometry(å¤–åŠå¾„, å†…åŠå¾„, ãƒãƒ¥ãƒ¼ãƒ–åˆ†å‰², å††å‘¨åˆ†å‰², p, q)
p ã¨ q ã¯ çµã³ç›®ã®ã­ã˜ã‚Œå…·åˆ
ã‚ˆã‚Šè¤‡é›‘ãªå½¢ã«ã™ã‚‹ã«ã¯ p=3, q=5
å½¢ã‚’å¤‰ãˆãŸã„å ´åˆã¯ TorusKnotGeometry(1.2, 0.4, 128, 32, 3, 7) ãªã©ã«å¤‰æ›´-->
<!--
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Reflective Torus Knot with Separate Background & Reflection</title>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@latest/build/three.module.min.js"
            }
        }
    </script>
</head>
<body>
    <script type="module">
        import * as THREE from 'three';

        // **ã‚·ãƒ¼ãƒ³ã€ã‚«ãƒ¡ãƒ©ã€ãƒ¬ãƒ³ãƒ€ãƒ©ãƒ¼ã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—**
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 0, 5);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const textureLoader = new THREE.TextureLoader();

        // **ç”»åƒãƒ•ã‚¡ã‚¤ãƒ«ã‚’æŒ‡å®š**
        const backgroundImagePath = './IMG_7940.JPG';  // **èƒŒæ™¯ç”»åƒ**
        const reflectionImagePath = './abstract_image1.png';  // **ãƒˆãƒ¼ãƒ©ã‚¹ãƒãƒƒãƒˆã®åå°„ç”»åƒ**

        // **èƒŒæ™¯ã¨åå°„ç”»åƒã‚’ãƒ­ãƒ¼ãƒ‰**
        textureLoader.load(backgroundImagePath, (backgroundTexture) => {
            backgroundTexture.colorSpace = THREE.SRGBColorSpace;

            // **èƒŒæ™¯ç”»åƒã‚’ãƒ¢ãƒã‚¯ãƒ­åŒ–**
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = backgroundTexture.image.width;
            canvas.height = backgroundTexture.image.height;
            ctx.drawImage(backgroundTexture.image, 0, 0);

            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            for (let i = 0; i < imageData.data.length; i += 4) {
                let gray = 0.299 * imageData.data[i] + 0.587 * imageData.data[i + 1] + 0.114 * imageData.data[i + 2];
                imageData.data[i] = gray;
                imageData.data[i + 1] = gray;
                imageData.data[i + 2] = gray;
            }
            ctx.putImageData(imageData, 0, 0);
            const grayscaleTexture = new THREE.CanvasTexture(canvas);

            // **èƒŒæ™¯ã‚’ãƒ¢ãƒã‚¯ãƒ­ã«è¨­å®š**
            scene.background = grayscaleTexture;

            // **ãƒˆãƒ¼ãƒ©ã‚¹ãƒãƒƒãƒˆã®åå°„ç”¨ç”»åƒã‚’ãƒ­ãƒ¼ãƒ‰**
            textureLoader.load(reflectionImagePath, (reflectionTexture) => {
                reflectionTexture.colorSpace = THREE.SRGBColorSpace;

                // **æ³•ç·šãƒãƒƒãƒ—ï¼ˆè¡¨é¢ã®å½±éŸ¿ã‚’å†ç¾ï¼‰**
                const normalMap = textureLoader.load('https://threejs.org/examples/textures/waternormals.jpg');
                normalMap.wrapS = normalMap.wrapT = THREE.RepeatWrapping;

                // **ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒãƒ†ãƒªã‚¢ãƒ«ã‚’ä½œæˆ**
                const refractiveShader = new THREE.ShaderMaterial({
                    uniforms: {
                        reflectionTexture: { value: reflectionTexture }, // **ãƒˆãƒ¼ãƒ©ã‚¹ãƒãƒƒãƒˆã®åå°„ç”»åƒ**
                        grayscaleTexture: { value: grayscaleTexture },  // **ãƒ¢ãƒã‚¯ãƒ­èƒŒæ™¯**
                        normalMap: { value: normalMap },
                        refractionStrength: { value: 0.02 }, // **å±ˆæŠ˜ã®å¼·ã•**
                        brightness: { value: 1.6 }, // **æ˜ã‚‹ã•è£œæ­£**
                        uCameraPosition: { value: camera.position } // **ã‚«ãƒ¡ãƒ©ã®ä½ç½®**
                    },
                    vertexShader: `
                        varying vec3 vNormal;
                        varying vec3 vViewPosition;
                        varying vec2 vUv;
                        
                        void main() {
                            vNormal = normalize(normalMatrix * normal);
                            vViewPosition = (modelViewMatrix * vec4(position, 1.0)).xyz;
                            vUv = uv;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform sampler2D reflectionTexture; // **ãƒˆãƒ¼ãƒ©ã‚¹ãƒãƒƒãƒˆã®åå°„ç”¨ç”»åƒ**
                        uniform sampler2D grayscaleTexture;  // **èƒŒæ™¯ç”»åƒï¼ˆãƒ¢ãƒã‚¯ãƒ­ï¼‰**
                        uniform sampler2D normalMap;
                        uniform float refractionStrength;
                        uniform float brightness;
                        uniform vec3 uCameraPosition;
                        varying vec3 vNormal;
                        varying vec3 vViewPosition;
                        varying vec2 vUv;

                        void main() {
                            // **æ³•ç·šãƒãƒƒãƒ—ã‚’é©ç”¨**
                            vec3 normalColor = texture2D(normalMap, vUv * 2.0).rgb * 2.0 - 1.0;
                            vec3 normal = normalize(vNormal + normalColor * 0.3);

                            // **è¦–ç‚¹æ–¹å‘ã¨æ³•ç·šã®è¨ˆç®—**
                            vec3 viewDir = normalize(uCameraPosition - vViewPosition);
                            vec3 refractDir = refract(viewDir, normal, refractionStrength);

                            // **åå°„ç”¨ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’ã‚«ãƒ©ãƒ¼ã§å–å¾—**
                            vec2 refractedUV = vUv + refractDir.xy * 0.2;
                            vec4 reflectionColor = texture2D(reflectionTexture, refractedUV);

                            // **æ˜ã‚‹ã•è£œæ­£**
                            reflectionColor.rgb *= brightness;

                            // **æœ€çµ‚ã‚«ãƒ©ãƒ¼ã‚’é©ç”¨**
                            gl_FragColor = vec4(reflectionColor.rgb, 1.0);
                        }
                    `,
                    transparent: true
                });

                // **ãƒˆãƒ¼ãƒ©ã‚¹ãƒãƒƒãƒˆã‚’ä½œæˆ**
                // const torusKnotGeometry = new THREE.TorusKnotGeometry(0.8, 0.3, 128, 32, 2, 3);
                const torusKnotGeometry = new THREE.TorusKnotGeometry(0.8, 0.3, 128, 32, 3, 7);
                const torusKnot = new THREE.Mesh(torusKnotGeometry, refractiveShader);
                scene.add(torusKnot);

                // **ç…§æ˜ã‚’è¿½åŠ ï¼ˆç’°å¢ƒå…‰ï¼‰**
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
                scene.add(ambientLight);

                const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
                directionalLight.position.set(5, 5, 5);
                scene.add(directionalLight);

                // **å›è»¢é€Ÿåº¦ã‚’è¨­å®š**
                let rotationSpeedX = 0.005;
                let rotationSpeedY = 0.007;

                // **ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ«ãƒ¼ãƒ—**
                function animate() {
                    requestAnimationFrame(animate);

                    // **ãƒˆãƒ¼ãƒ©ã‚¹ãƒãƒƒãƒˆã‚’å›è»¢**
                    torusKnot.rotation.x += rotationSpeedX;
                    torusKnot.rotation.y += rotationSpeedY;

                    // **ã‚«ãƒ¡ãƒ©ä½ç½®ã‚’ãƒˆãƒ¼ãƒ©ã‚¹ãƒãƒƒãƒˆã®å›è»¢ã«å¿œã˜ã¦æ›´æ–°**
                    refractiveShader.uniforms.uCameraPosition.value.copy(camera.position);

                    renderer.render(scene, camera);
                }

                animate();
            });
        });

    </script>
</body>
</html>
-->

<!--GLBãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Reflective Blender Model with BufferGeometry</title>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@latest/build/three.module.min.js",
                "three/examples/jsm/": "https://cdn.jsdelivr.net/npm/three@latest/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';

        // **ã‚·ãƒ¼ãƒ³ã€ã‚«ãƒ¡ãƒ©ã€ãƒ¬ãƒ³ãƒ€ãƒ©ãƒ¼ã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—**
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 2, 5);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const textureLoader = new THREE.TextureLoader();

        // **ç”»åƒãƒ•ã‚¡ã‚¤ãƒ«ã‚’æŒ‡å®š**
        const backgroundImagePath = './IMG_7940.JPG';  // **èƒŒæ™¯ç”»åƒ**
        const reflectionImagePath = './abstract_image1.png';  // **3Dãƒ¢ãƒ‡ãƒ«ã®åå°„ç”»åƒ**

        // **èƒŒæ™¯ã¨åå°„ç”»åƒã‚’ãƒ­ãƒ¼ãƒ‰**
        textureLoader.load(backgroundImagePath, (backgroundTexture) => {
            backgroundTexture.colorSpace = THREE.SRGBColorSpace;

            // **èƒŒæ™¯ç”»åƒã‚’ãƒ¢ãƒã‚¯ãƒ­åŒ–**
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = backgroundTexture.image.width;
            canvas.height = backgroundTexture.image.height;
            ctx.drawImage(backgroundTexture.image, 0, 0);

            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            for (let i = 0; i < imageData.data.length; i += 4) {
                let gray = 0.299 * imageData.data[i] + 0.587 * imageData.data[i + 1] + 0.114 * imageData.data[i + 2];
                imageData.data[i] = gray;
                imageData.data[i + 1] = gray;
                imageData.data[i + 2] = gray;
            }
            ctx.putImageData(imageData, 0, 0);
            const grayscaleTexture = new THREE.CanvasTexture(canvas);

            // **èƒŒæ™¯ã‚’ãƒ¢ãƒã‚¯ãƒ­ã«è¨­å®š**
            scene.background = grayscaleTexture;

            // **3Dãƒ¢ãƒ‡ãƒ«ã®åå°„ç”¨ç”»åƒã‚’ãƒ­ãƒ¼ãƒ‰**
            textureLoader.load(reflectionImagePath, (reflectionTexture) => {
                reflectionTexture.colorSpace = THREE.SRGBColorSpace;

                // **æ³•ç·šãƒãƒƒãƒ—ï¼ˆè¡¨é¢ã®å½±éŸ¿ã‚’å†ç¾ï¼‰**
                const normalMap = textureLoader.load('https://threejs.org/examples/textures/waternormals.jpg');
                normalMap.wrapS = normalMap.wrapT = THREE.RepeatWrapping;

                // **ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒãƒ†ãƒªã‚¢ãƒ«ã‚’ä½œæˆ**
                const refractiveShader = new THREE.ShaderMaterial({
                    uniforms: {
                        reflectionTexture: { value: reflectionTexture }, // **3Dãƒ¢ãƒ‡ãƒ«ã®åå°„ç”»åƒ**
                        grayscaleTexture: { value: grayscaleTexture },  // **ãƒ¢ãƒã‚¯ãƒ­èƒŒæ™¯**
                        normalMap: { value: normalMap },
                        refractionStrength: { value: 0.02 }, // **å±ˆæŠ˜ã®å¼·ã•**
                        brightness: { value: 1.6 }, // **æ˜ã‚‹ã•è£œæ­£**
                        uCameraPosition: { value: camera.position } // **ã‚«ãƒ¡ãƒ©ã®ä½ç½®**
                    },
                    vertexShader: `
                        varying vec3 vNormal;
                        varying vec3 vViewPosition;
                        varying vec2 vUv;
                        
                        void main() {
                            vNormal = normalize(normalMatrix * normal);
                            vViewPosition = (modelViewMatrix * vec4(position, 1.0)).xyz;
                            vUv = uv;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform sampler2D reflectionTexture; // **3Dãƒ¢ãƒ‡ãƒ«ã®åå°„ç”¨ç”»åƒ**
                        uniform sampler2D grayscaleTexture;  // **èƒŒæ™¯ç”»åƒï¼ˆãƒ¢ãƒã‚¯ãƒ­ï¼‰**
                        uniform sampler2D normalMap;
                        uniform float refractionStrength;
                        uniform float brightness;
                        uniform vec3 uCameraPosition;
                        varying vec3 vNormal;
                        varying vec3 vViewPosition;
                        varying vec2 vUv;

                        void main() {
                            // **æ³•ç·šãƒãƒƒãƒ—ã‚’é©ç”¨**
                            vec3 normalColor = texture2D(normalMap, vUv * 2.0).rgb * 2.0 - 1.0;
                            vec3 normal = normalize(vNormal + normalColor * 0.3);

                            // **è¦–ç‚¹æ–¹å‘ã¨æ³•ç·šã®è¨ˆç®—**
                            vec3 viewDir = normalize(uCameraPosition - vViewPosition);
                            vec3 refractDir = refract(viewDir, normal, refractionStrength);

                            // **åå°„ç”¨ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’ã‚«ãƒ©ãƒ¼ã§å–å¾—**
                            vec2 refractedUV = vUv + refractDir.xy * 0.2;
                            vec4 reflectionColor = texture2D(reflectionTexture, refractedUV);

                            // **æ˜ã‚‹ã•è£œæ­£**
                            reflectionColor.rgb *= brightness;

                            // **æœ€çµ‚ã‚«ãƒ©ãƒ¼ã‚’é©ç”¨**
                            gl_FragColor = vec4(reflectionColor.rgb, 1.0);
                        }
                    `,
                    transparent: true
                });

                // **Blenderã§ä½œæˆã—ãŸ3Dãƒ‡ãƒ¼ã‚¿ï¼ˆGLB/GLTFï¼‰ã‚’ãƒ­ãƒ¼ãƒ‰**
                const loader = new GLTFLoader();
                loader.load('./model5.glb', (gltf) => {
                    const model = gltf.scene;

                    // **ãƒ¢ãƒ‡ãƒ«ã® BufferGeometry ã«å¤‰æ›´**
                    model.traverse((child) => {
                        if (child.isMesh) {
                            child.geometry = new THREE.BufferGeometry().copy(child.geometry);
                            child.geometry.computeVertexNormals();
                            child.material = refractiveShader;
                        }
                    });

                    // **ãƒ¢ãƒ‡ãƒ«ã‚’ã‚·ãƒ¼ãƒ³ã«è¿½åŠ **
                    scene.add(model);
                    model.position.set(0, 2, 0);

                    // **å›è»¢é€Ÿåº¦ã‚’è¨­å®š**
                    let rotationSpeedX = 0.005;
                    let rotationSpeedY = 0.007;

                    // **ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ«ãƒ¼ãƒ—**
                    function animate() {
                        requestAnimationFrame(animate);

                        // **ãƒ¢ãƒ‡ãƒ«ã‚’å›è»¢**
                        model.rotation.x += rotationSpeedX;
                        model.rotation.y += rotationSpeedY;

                        // **ã‚«ãƒ¡ãƒ©ä½ç½®ã‚’ãƒ¢ãƒ‡ãƒ«ã®å›è»¢ã«å¿œã˜ã¦æ›´æ–°**
                        refractiveShader.uniforms.uCameraPosition.value.copy(camera.position);

                        renderer.render(scene, camera);
                    }

                    animate();
                });
            });
        });

    </script>
</body>
</html>
-->

<!--ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼çƒä½“ã€€ä½ç½®ãƒ©ãƒ³ãƒ€ãƒ 
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Refractive Sphere with Monochrome Background</title>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@latest/build/three.module.min.js"
            }
        }
    </script>
</head>
<body>
    <script type="module">
        import * as THREE from 'three';

        // **ã‚·ãƒ¼ãƒ³ã€ã‚«ãƒ¡ãƒ©ã€ãƒ¬ãƒ³ãƒ€ãƒ©ãƒ¼ã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—**
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 0, 5);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const textureLoader = new THREE.TextureLoader();

        // **ç”»åƒãƒ•ã‚¡ã‚¤ãƒ«ã‚’æŒ‡å®š**
        const backgroundImagePath = './IMG_7948.JPG';
        const reflectionImagePath = './abstract_water_style.png';

        // **èƒŒæ™¯ã‚’ãƒ¢ãƒã‚¯ãƒ­ã«å¤‰æ›**
        function convertToGrayscale(imageTexture) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = imageTexture.image.width;
            canvas.height = imageTexture.image.height;
            ctx.drawImage(imageTexture.image, 0, 0);

            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            for (let i = 0; i < imageData.data.length; i += 4) {
                let gray = 0.299 * imageData.data[i] + 0.587 * imageData.data[i + 1] + 0.114 * imageData.data[i + 2];
                imageData.data[i] = gray;
                imageData.data[i + 1] = gray;
                imageData.data[i + 2] = gray;
            }
            ctx.putImageData(imageData, 0, 0);
            return new THREE.CanvasTexture(canvas);
        }

        // **ãƒ©ãƒ³ãƒ€ãƒ ãªçƒä½“ã®ä½ç½®ã‚’æ±ºå®š**
        function getRandomPosition() {
            let insideScreen = Math.random() < 0.8;
            let x, y, z;
            
            if (insideScreen) {
                x = (Math.random() - 0.5) * 3;
                y = (Math.random() - 0.5) * 3;
                z = -2.5 + Math.random() * 4;
            } else {
                x = (Math.random() - 0.5) * 6;
                y = (Math.random() - 0.5) * 6;
                z = -4.5 + Math.random() * 7.5;
            }

            return new THREE.Vector3(x, y, z);
        }

        // **ãƒ©ãƒ³ãƒ€ãƒ ãªå›è»¢é€Ÿåº¦ã‚’è¨­å®š**
        function getRandomRotationSpeed() {
            return (Math.random() - 0.5) * 0.02;
        }

        // **èƒŒæ™¯ç”»åƒã‚’ãƒ­ãƒ¼ãƒ‰**
        textureLoader.load(backgroundImagePath, (backgroundTexture) => {
            backgroundTexture.colorSpace = THREE.SRGBColorSpace;
            
            // **èƒŒæ™¯ã‚’ãƒ¢ãƒã‚¯ãƒ­åŒ–**
            const grayscaleTexture = convertToGrayscale(backgroundTexture);
            scene.background = grayscaleTexture;

            // **çƒä½“ã®åå°„ç”¨ç”»åƒã‚’ãƒ­ãƒ¼ãƒ‰**
            textureLoader.load(reflectionImagePath, (reflectionTexture) => {
                reflectionTexture.colorSpace = THREE.SRGBColorSpace;

                // **æ³•ç·šãƒãƒƒãƒ—**
                const normalMap = textureLoader.load('https://threejs.org/examples/textures/waternormals.jpg');
                normalMap.wrapS = normalMap.wrapT = THREE.RepeatWrapping;

                // **ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒãƒ†ãƒªã‚¢ãƒ«ã‚’ä½œæˆ**
                const refractiveShader = new THREE.ShaderMaterial({
                    uniforms: {
                        reflectionTexture: { value: reflectionTexture },
                        grayscaleTexture: { value: grayscaleTexture },
                        normalMap: { value: normalMap },
                        refractionStrength: { value: 0.03 },
                        brightness: { value: 1.5 },
                        uCameraPosition: { value: camera.position }
                    },
                    vertexShader: `
                        varying vec3 vNormal;
                        varying vec3 vViewPosition;
                        varying vec2 vUv;
                        
                        void main() {
                            vNormal = normalize(normalMatrix * normal);
                            vViewPosition = (modelViewMatrix * vec4(position, 1.0)).xyz;
                            vUv = uv;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform sampler2D reflectionTexture;
                        uniform sampler2D grayscaleTexture;
                        uniform sampler2D normalMap;
                        uniform float refractionStrength;
                        uniform float brightness;
                        uniform vec3 uCameraPosition;
                        varying vec3 vNormal;
                        varying vec3 vViewPosition;
                        varying vec2 vUv;

                        void main() {
                            vec3 normalColor = texture2D(normalMap, vUv * 2.0).rgb * 2.0 - 1.0;
                            vec3 normal = normalize(vNormal + normalColor * 0.2);

                            vec3 viewDir = normalize(uCameraPosition - vViewPosition);
                            vec3 refractDir = refract(viewDir, normal, refractionStrength);

                            vec2 refractedUV = vUv + refractDir.xy * 0.1;
                            vec4 reflectionColor = texture2D(reflectionTexture, refractedUV);

                            reflectionColor.rgb *= brightness;

                            gl_FragColor = vec4(reflectionColor.rgb, 1.0);
                        }
                    `,
                    transparent: true
                });

                // **çƒä½“ã‚’ä½œæˆ**
                const sphereGeometry = new THREE.SphereGeometry(1, 128, 128);
                const sphere = new THREE.Mesh(sphereGeometry, refractiveShader);

                // **ãƒ©ãƒ³ãƒ€ãƒ ãªä½ç½®ã¨å›è»¢é€Ÿåº¦ã‚’è¨­å®š**
                sphere.position.copy(getRandomPosition());
                let rotationSpeedX = getRandomRotationSpeed();
                let rotationSpeedY = getRandomRotationSpeed();
                scene.add(sphere);

                // **ç…§æ˜ã‚’è¿½åŠ **
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
                scene.add(ambientLight);

                const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
                directionalLight.position.set(5, 5, 5);
                scene.add(directionalLight);

                // **ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ«ãƒ¼ãƒ—**
                function animate() {
                    requestAnimationFrame(animate);

                    // **çƒä½“ã®å›è»¢**
                    sphere.rotation.x += rotationSpeedX;
                    sphere.rotation.y += rotationSpeedY;

                    refractiveShader.uniforms.uCameraPosition.value.copy(camera.position);

                    renderer.render(scene, camera);
                }

                animate();
            });
        });
    </script>
</body>
</html>
-->

<!--ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒ—ãƒ¬ãƒ¼ãƒˆã€€ä½ç½®ãƒ©ãƒ³ãƒ€ãƒ -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Refractive Plate with Monochrome Background</title>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@latest/build/three.module.min.js"
            }
        }
    </script>
</head>
<body>
    <script type="module">
        import * as THREE from 'three';

        // **ã‚·ãƒ¼ãƒ³ã€ã‚«ãƒ¡ãƒ©ã€ãƒ¬ãƒ³ãƒ€ãƒ©ãƒ¼ã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—**
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 0, 5);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const textureLoader = new THREE.TextureLoader();

        // **ç”»åƒãƒ•ã‚¡ã‚¤ãƒ«ã‚’æŒ‡å®š**
        const backgroundImagePath = './IMG_7964.JPG';
        const reflectionImagePath = './abstract_night_style_2.png';

        // **èƒŒæ™¯ã‚’ãƒ¢ãƒã‚¯ãƒ­ã«å¤‰æ›**
        function convertToGrayscale(imageTexture) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = imageTexture.image.width;
            canvas.height = imageTexture.image.height;
            ctx.drawImage(imageTexture.image, 0, 0);

            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            for (let i = 0; i < imageData.data.length; i += 4) {
                let gray = 0.299 * imageData.data[i] + 0.587 * imageData.data[i + 1] + 0.114 * imageData.data[i + 2];
                imageData.data[i] = gray;
                imageData.data[i + 1] = gray;
                imageData.data[i + 2] = gray;
            }
            ctx.putImageData(imageData, 0, 0);
            return new THREE.CanvasTexture(canvas);
        }

        // **ãƒ©ãƒ³ãƒ€ãƒ ãªãƒ—ãƒ¬ãƒ¼ãƒˆã®ä½ç½®ã‚’æ±ºå®š**
        function getRandomPosition() {
            let insideScreen = Math.random() < 0.8;
            let x, y, z;
            
            if (insideScreen) {
                x = (Math.random() - 0.5) * 3;
                y = (Math.random() - 0.5) * 3;
                z = -2.5 + Math.random() * 4;
            } else {
                x = (Math.random() - 0.5) * 6;
                y = (Math.random() - 0.5) * 6;
                z = -4.5 + Math.random() * 7.5;
            }

            return new THREE.Vector3(x, y, z);
        }

        // **ãƒ©ãƒ³ãƒ€ãƒ ãªå›è»¢é€Ÿåº¦ã‚’è¨­å®š**
        function getRandomRotationSpeed() {
            return (Math.random() - 0.5) * 0.02;
        }

        // **èƒŒæ™¯ç”»åƒã‚’ãƒ­ãƒ¼ãƒ‰**
        textureLoader.load(backgroundImagePath, (backgroundTexture) => {
            backgroundTexture.colorSpace = THREE.SRGBColorSpace;
            
            // **èƒŒæ™¯ã‚’ãƒ¢ãƒã‚¯ãƒ­åŒ–**
            const grayscaleTexture = convertToGrayscale(backgroundTexture);
            scene.background = grayscaleTexture;

            // **ãƒ—ãƒ¬ãƒ¼ãƒˆã®åå°„ç”¨ç”»åƒã‚’ãƒ­ãƒ¼ãƒ‰**
            textureLoader.load(reflectionImagePath, (reflectionTexture) => {
                reflectionTexture.colorSpace = THREE.SRGBColorSpace;

                // **æ³•ç·šãƒãƒƒãƒ—**
                const normalMap = textureLoader.load('https://threejs.org/examples/textures/waternormals.jpg');
                normalMap.wrapS = normalMap.wrapT = THREE.RepeatWrapping;

                // **ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒãƒ†ãƒªã‚¢ãƒ«ã‚’ä½œæˆ**
                const refractiveShader = new THREE.ShaderMaterial({
                    uniforms: {
                        reflectionTexture: { value: reflectionTexture },
                        grayscaleTexture: { value: grayscaleTexture },
                        normalMap: { value: normalMap },
                        refractionStrength: { value: 0.03 },
                        brightness: { value: 1.5 },
                        uCameraPosition: { value: camera.position }
                    },
                    vertexShader: `
                        varying vec3 vNormal;
                        varying vec3 vViewPosition;
                        varying vec2 vUv;
                        
                        void main() {
                            vNormal = normalize(normalMatrix * normal);
                            vViewPosition = (modelViewMatrix * vec4(position, 1.0)).xyz;
                            vUv = uv;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform sampler2D reflectionTexture;
                        uniform sampler2D grayscaleTexture;
                        uniform sampler2D normalMap;
                        uniform float refractionStrength;
                        uniform float brightness;
                        uniform vec3 uCameraPosition;
                        varying vec3 vNormal;
                        varying vec3 vViewPosition;
                        varying vec2 vUv;

                        void main() {
                            vec3 normalColor = texture2D(normalMap, vUv * 2.0).rgb * 2.0 - 1.0;
                            vec3 normal = normalize(vNormal + normalColor * 0.2);

                            vec3 viewDir = normalize(uCameraPosition - vViewPosition);
                            vec3 refractDir = refract(viewDir, normal, refractionStrength);

                            vec2 refractedUV = vUv + refractDir.xy * 0.1;
                            vec4 reflectionColor = texture2D(reflectionTexture, refractedUV);

                            reflectionColor.rgb *= brightness;

                            gl_FragColor = vec4(reflectionColor.rgb, 1.0);
                        }
                    `,
                    transparent: true
                });

                // **æ­£æ–¹å½¢ãƒ—ãƒ¬ãƒ¼ãƒˆï¼ˆBoxGeometryï¼‰ã‚’ä½œæˆ**
                const plateGeometry = new THREE.BoxGeometry(2, 2, 0.1); // **åšã¿ã‚’0.1ã«ã—ã¦è–„ã**
                const plate = new THREE.Mesh(plateGeometry, refractiveShader);

                // **ãƒ©ãƒ³ãƒ€ãƒ ãªä½ç½®ã¨å›è»¢é€Ÿåº¦ã‚’è¨­å®š**
                plate.position.copy(getRandomPosition());
                let rotationSpeedX = getRandomRotationSpeed();
                let rotationSpeedY = getRandomRotationSpeed();
                scene.add(plate);

                // **ç…§æ˜ã‚’è¿½åŠ **
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
                scene.add(ambientLight);

                const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
                directionalLight.position.set(5, 5, 5);
                scene.add(directionalLight);

                // **ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ«ãƒ¼ãƒ—**
                function animate() {
                    requestAnimationFrame(animate);

                    // **ãƒ—ãƒ¬ãƒ¼ãƒˆã®å›è»¢**
                    plate.rotation.x += rotationSpeedX;
                    plate.rotation.y += rotationSpeedY;

                    refractiveShader.uniforms.uCameraPosition.value.copy(camera.position);

                    renderer.render(scene, camera);
                }

                animate();
            });
        });
    </script>
</body>
</html>
